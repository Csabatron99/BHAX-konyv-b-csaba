<?xml version="1.0" encoding="UTF-8"?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:lang="hu">    
    
    <info xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">

    <title xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Univerzális programozás</title>               

    <subtitle xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">Így neveld a programozód!</subtitle>               

    <titleabbrev xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX KÖNYV</titleabbrev>               

    <authorgroup xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
  <author>
    <personname>
      <surname>Balla</surname>
      <firstname>Csaba</firstname>
    </personname>
    <affiliation>
      <shortaffil>Hallgató, DE.</shortaffil>
      <jobtitle>Egyetemi halgató</jobtitle>
      <orgname>Debreceni Egyetem</orgname>
      <orgdiv>Informatika kar. Programtervező informatikus szak.</orgdiv>
      <address>
        <email>csabatron99@gmail.com</email>
      </address>
    </affiliation>
  </author>
</authorgroup>               

    <edition xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">BHAX, DEBRECEN, 2019. február 19, v. 0.0.4</edition>               

    <pubdate>2019</pubdate>
    <copyright>
        <year>2019</year>
        <holder>Dr. Bátfai Norbert</holder>
    </copyright>
    <legalnotice>           
        <para>                
            Copyright (C) 2019, Norbert Bátfai Ph.D., batfai.norbert@inf.unideb.hu, nbatfai@gmail.com, 
        </para>
        <para>
            Permission is granted to copy, distribute and/or modify this document
            under the terms of the GNU Free Documentation License, Version 1.3
            or any later version published by the Free Software Foundation;
            with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
            A copy of the license is included in the section entitled "GNU
            Free Documentation License".                
        </para>
        <para>
            <link xlink:href="https://www.gnu.org/licenses/fdl.html">https://www.gnu.org/licenses/fdl.html</link>                
        </para>
            
        <para>
            Engedélyt adunk Önnek a jelen dokumentum sokszorosítására, terjesztésére és/vagy módosítására 
            a Free Software Foundation által kiadott GNU FDL 1.3-as, vagy bármely azt követő verziójának 
            feltételei alapján. Nincs Nem Változtatható szakasz, nincs Címlapszöveg, nincs Hátlapszöveg.                
        </para>
        <para>
            <link xlink:href="http://gnu.hu/fdl.html">http://gnu.hu/fdl.html</link>                
        </para>
    </legalnotice>   
    
    <revhistory xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <revision>
        <revnumber>0.0.1</revnumber>
        <date>2019-02-12</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Az iniciális dokumentum szerkezetének kialakítása.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.2</revnumber>
        <date>2019-02-14</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Inciális feladatlisták összeállítása.
        </revremark>
    </revision>    
    <revision>
        <revnumber>0.0.3</revnumber>
        <date>2019-02-16</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            Feladatlisták folytatása.
            Feltöltés a BHAX csatorna 
            <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
            repójába.
        </revremark>
    </revision>
    <revision>
        <revnumber>0.0.4</revnumber>
        <date>2019-02-19</date>
        <authorinitials>nbatfai</authorinitials>
        <revremark>
            A Brun tételes feladat kidolgozása.
        </revremark>
    </revision>
    <revision>
      <revnumber>0.1.0</revnumber>
      <date>2020-02-22</date>
      <authorinitials>Csabatron99</authorinitials>
      <revremark>
        A feladatok kidolgozásának kidolgozása. A könyv kidolgozásának elkezdése.

      </revremark>
    </revision>
</revhistory>               
                               
</info>     
        
    <dedication xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>

    </para>
<blockquote>
    <attribution>Gregory Chaitin, <citetitle>META MATH! The Quest for Omega</citetitle>, <citation>METAMATH</citation></attribution>
    <para>
        „To me, you understand something only if you can program it.  
        (You, not someone else!)  Otherwise you don’t really understand it, 
        you only think you understand it.”
    </para>
</blockquote>
</dedication>     
    
    <preface xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Előszó</title>
    <para xml:id="bhax-textbook-pre.Eloszo">
        Amikor programozónak terveztem állni, ellenezték a környezetemben, mondván, hogy kell  
        szövegszerkesztő meg táblázatkezelő, de az már van... nem lesz programozói munka.
    </para>                 
    <para>
        Tévedtek. Hogy egy generáció múlva kell-e még tömegesen hús-vér programozó vagy
        olcsóbb lesz allokálni igény szerint pár robot programozót a felhőből?
        A programozók dolgozók lesznek vagy papok?
        Ki tudhatná ma. 
    </para>
    <para>
        Mindenesetre a programozás a teoretikus kultúra csúcsa. A GNU mozgalomban látom annak 
        garanciáját, hogy ebben a szellemi kalandban a gyerekeim is részt vehessenek majd. Ezért programozunk.
    </para>          
    <section>
        <title>Hogyan forgasd</title>
        <para>
            A könyv célja egy stabil programozási szemlélet kialakítása az olvasóban. Módszere, hogy hetekre 
            bontva ad egy tematikus feladatcsokrot. Minden feladathoz megadja a megoldás forráskódját és forrásokat
            feldolgozó videókat.
            Az olvasó feladata, hogy ezek tanulmányozása után maga adja meg a feladat megoldásának lényegi
            magyarázatát, avagy írja meg a könyvet.
        </para>
        <para>
            Miért univerzális? Mert az olvasótól (kvázi az írótól) függ, hogy kinek szól a könyv. 
            Alapértelmezésben gyerekeknek, mert velük készítem az iniciális változatot. 
            Ám tervezem felhasználását az egyetemi programozás oktatásban is. Ahogy szélesedni tudna a 
            felhasználók köre, akkor lehetne kiadása különböző korosztályú gyerekeknek, családoknak, 
            szakköröknek, programozás kurzusoknak, felnőtt és továbbképzési műhelyeknek és sorolhatnánk... 
        </para>
        <section>
            <title>Milyen nyelven nyomjuk?</title>
            <para>
                C (mutatók), C++ (másoló és mozgató szemantika) és Java (lebutított C++) nyelvekből kell egy jó alap, 
                ezt kell kiegészíteni pár R (vektoros szemlélet), Python (gépi tanulás bevezető), Lisp és Prolog (hogy lássuk
                mást is) példával.
            </para>
        </section>
        <section>
            <title>Hogyan nyomjuk?</title>
            <para>
                Rántsd le a <link xlink:href="https://gitlab.com/nbatfai/bhax">https://gitlab.com/nbatfai/bhax</link>
                git repót, vagy méginkább forkolj belőle magadnak egy sajátot a GitLabon, ha már saját könyvön dolgozol!
            
                <screen><![CDATA[]]></screen> 
            
            </para>
            <para>
                Ha megvannak a könyv DocBook XML forrásai, 
                akkor az alább látható <command>make</command> parancs ellenőrzi, hogy „jól formázottak” és 
                „érvényesek-e” ezek az XML források, majd 
                elkészíti a <application>dblatex</application> programmal a könyved pdf változatát, íme:
                <screen><![CDATA[batfai@entropy:~$ cd glrepos/bhax/thematic_tutorials/bhax_textbook/
batfai@entropy:~/glrepos/bhax/thematic_tutorials/bhax_textbook$ make
rm -f bhax-textbook-fdl.pdf
xmllint --xinclude bhax-textbook-fdl.xml --output output.xml
xmllint --relaxng http://docbook.org/xml/5.0/rng/docbookxi.rng output.xml --noout
output.xml validates
rm -f output.xml	
dblatex bhax-textbook-fdl.xml -p bhax-textbook.xls
Build the book set list...
Build the listings...
XSLT stylesheets DocBook - LaTeX 2e (0.3.10)
===================================================
Stripping NS from DocBook 5/NG document.
Processing stripped document.
Image 'dblatex' not found
Build bhax-textbook-fdl.pdf
'bhax-textbook-fdl.pdf' successfully built]]></screen>             

            Ha minden igaz, akkor most éppen ezt a legenerált <filename>bhax-textbook-fdl.pdf</filename> fájlt olvasod.
            </para>
<tip>
              <title>A DocBook XML 5.1 új neked?</title>
              <para>
                  Ez esetben forgasd a <link xlink:href="https://tdg.docbook.org/tdg/5.1/">https://tdg.docbook.org/tdg/5.1/</link>
                  könyvet, a végén találod az informatikai szövegek jelölésére használható gazdag „API” elemenkénti
                  bemutatását.                  
              </para>            
            </tip>            
        </section>
        
    </section>            

</preface> 

    <!-- 
        <xi:include href="bhax-textbook-glossary.xml">
            <xi:fallback>
                <para>
                    <emphasis>XInclude: bhax-textbook-glossary.xml file not found</emphasis>
                </para>
            </xi:fallback>
        </xi:include> 
    -->

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Bevezetés</title>
    <partintro>
        <para> 
        </para>
    </partintro>
    <chapter>
        <info>
            <title>Vízió</title>
            <keywordset>
                <keyword/>
            </keywordset>
        </info>
        <section>
          <title>Mi a programozás?</title>
          <para>
            Ne cifrázzuk: programok írása. Mik akkor a programok? Mit jelent az írásuk?
            Számítógép-programozás (vagy egyszerűen programozás) egy vagy több absztrakt algoritmus megvalósítását jelenti egy bizonyos programozási nyelven. A programozásban megtaláljuk a művészet, a tudomány, a matematika és a mérnöki tudomány elemeit.

            A programok maga az az utasítás vagy utasítás sorozat ami vezérel egy számítógépet. Valamint segíti a felhasználót( Szoftverek ) a számítógép netalántán más gépek használatában, vagy elszörakoztatja( Játékok )
            azt különböző szórakoztató programokkal. Ennek a skálája végtelennek tekinthető, hogy miket lehet létrehozni ebben a szakmában.

            <Title>Az írásuknak van egy úgymond részei:</Title>
            <itemizedlist>
              <listitem>
                1. A megoldandó probléma meghatározása, felmérése a majdani felhasználók igényei alapján, specifikáció készítése
              </listitem>
              <listitem>
                2. Valamely programtervezési módszerrel a programszerkezet megalkotása és a használandó eszközök kiválasztása. (Hardver platform, nyelvek, adatok stb…)
              </listitem>
              <listitem>
                3. Forrásprogram elkészítése (kódolás)
              </listitem>
              <listitem>
                4. A kész program tesztelése
              </listitem>
              <listitem>
                5. Dokumentáció készítése, mely tartalmazza a szoftvertervezés fázisaiban keletkezett adatokat (felhasználói leírás, igényfelmérés, programtervek, algoritmusok, forráskód, tesztelési jegyzőkönyvek stb.),
                fő célja a szoftver későbbi fejlesztésének elősegítése.
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section>
            <title>Milyen doksikat olvassak el?</title>
            <itemizedlist>
                <listitem>
                    <para>Kezd ezzel: <link xlink:href="http://esr.fsf.hu/hacker-howto.html">http://esr.fsf.hu/hacker-howto.html</link>!</para>                        
                </listitem>
                <listitem>
                    <para>Olvasgasd aztán a kézikönyv lapjait, kezd a <command>man man</command> parancs kiadásával. A C programozásban
                    a 3-as szintű lapokat fogod nézegetni, például az első feladat kapcsán ezt a 
                    <command>man 3 sleep</command> lapot</para>                        
                </listitem>
                <listitem>
                    <para>C kapcsán a <citation>KERNIGHANRITCHIE</citation> könyv adott részei.</para>                        
                </listitem>
                <listitem>
                    <para>C++ kapcsán a <citation>BMECPP</citation> könyv adott részei.</para>                        
                </listitem>
                <listitem>
                    <para>Az igazi kockák persze csemegéznek a C nyelvi szabvány 
                        <link xlink:href="https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf">ISO/IEC 9899:2017</link> kódcsipeteiből is.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Amiből viszont a legeslegjobban lehet tanulni, az a 
                        <link xlink:href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html">The GNU C Reference Manual</link>, mert gcc specifikus és programozókra
                        van hangolva: szinte csak 1-2 lényegi mondat és apró, lényegi kódcsipetek! Aki pdf-ben jobban
                        szereti olvasni: <link xlink:href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.pdf"/>
                    </para>                        
                </listitem>
                <listitem>
                    <para>Az R kódok olvasása kis általános tapasztalat után automatikusan, erőfeszítés nélkül menni fog. 
                        A Python nincs ennyire a spektrum magától értetődő végén, ezért ahhoz olvasd el a  
                        <citation>BMECPP</citation> könyv - 20 oldalas gyorstalpaló részét.
                    </para>                        
                </listitem>
            </itemizedlist>            
        </section>
        <section>
            <title>Milyen filmeket nézzek meg?</title>
            <itemizedlist>
                <listitem>
                    <para>21 - Las Vegas ostroma, 
                        <link xlink:href="https://www.imdb.com/title/tt0478087/">https://www.imdb.com/title/tt0478087/</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-turing.MontyHall">Monty Hall probléma</link> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>Kódjátszma, 
                        <link xlink:href="https://www.imdb.com/title/tt2084970">https://www.imdb.com/title/tt2084970</link>,
                        benne a <link xlink:href="#bhax-textbook-feladatok-caesar.EXOR-toro">kódtörő feladat</link> élménye.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
                <listitem>
                    <para>, 
                        <link xlink:href=""/>,
                        benne a <link xlink:href="#"/> bemutatása.
                    </para>                        
                </listitem>
            </itemizedlist> 
        </section>
    </chapter>                
</part> 

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Tematikus feladatok</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
  <section><para>A kódok megtekínthetőek githubon. Link: <link xlink:href="https://github.com/Csabatron99/BHAX-konyv-b-csaba/tree/master/Source%20Codes">https://github.com/Csabatron99/BHAX-konyv-b-csaba/tree/master/Source%20Codes </link></para></section>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó(nbatfai): <link xlink:href="https://youtu.be/lvmi6tyz-nI">https://youtu.be/lvmi6tyz-nI</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Turing/infty-f.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-f.c</filename>
            </link>, 
            <link xlink:href="Turing/infty-w.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/infty-w.c</filename>
            </link>.
        </para>
        <para>
            Számos módon hozhatunk és hozunk létre végtelen ciklusokat. 
            Vannak esetek, amikor ez a célunk, például egy szerverfolyamat fusson folyamatosan és van amikor egy
            bug, mert ott lesz végtelen ciklus, ahol nem akartunk. Saját péláinkban ilyen amikor a PageRank algoritmus
            rázza az 1 liter vizet az internetben, de az iteráció csak nem akar konvergálni...
        </para>                    
        <para>
            Egy mag 100 százalékban:               
        </para>
        <programlisting language="c"><![CDATA[int
main ()
{
  for (;;);

  return 0;
}
]]>
        </programlisting>        
        <para>        
        vagy az olvashatóbb, de a programozók és fordítók (szabványok) között kevésbé hordozható
        </para>
        <programlisting language="c"><![CDATA[int
#include <stdbool.h>
main ()
{
  while(true);

  return 0;
}
]]>
        </programlisting>        
        <para>
            Azért érdemes a <literal>for(;;)</literal> hagyományos formát használni, 
            mert ez minden C szabvánnyal lefordul, másrészt
            a többi programozó azonnal látja, hogy az a végtelen ciklus szándékunk szerint végtelen és nem szoftverhiba. 
            Mert ugye, ha a <literal>while</literal>-al trükközünk egy nem triviális 
            <literal>1</literal> vagy <literal>true</literal> feltétellel, akkor ott egy másik, a forrást
            olvasó programozó nem látja azonnal a szándékunkat.
        </para>            
        <para>
            Egyébként a fordító a <literal>for</literal>-os és 
            <literal>while</literal>-os ciklusból ugyanazt az assembly kódot fordítja:
        </para>            
        <screen><![CDATA[$ gcc -S -o infty-f.S infty-f.c 
$ gcc -S -o infty-w.S infty-w.c 
$ diff infty-w.S infty-f.S 
1c1
< 	.file	"infty-w.c"
---
> 	.file	"infty-f.c"
]]></screen>  
        <para>
            Egy mag 0 százalékban:               
        </para>        
        <programlisting language="c"><![CDATA[#include <unistd.h>
int
main ()
{
  for (;;)
    sleep(1);
    
  return 0;
}
]]>
        </programlisting>        
        <para>
            Minden mag 100 százalékban:               
        </para>

        <programlisting language="c"><![CDATA[#include <omp.h>
int
main ()
{
#pragma omp parallel
{
  for (;;);
}
  return 0;
}
]]>
        </programlisting>        
        <para>
            A <command>gcc [filename].c -o [filename] -fopenmp</command> parancssorral készítve a futtathatót, majd futtatva,               
            közben egy másik terminálban a <command>top</command> parancsot kiadva tanulmányozzuk, mennyi CPU-t használunk:            
        </para>
        <screen><![CDATA[top - 20:09:06 up  3:35,  1 user,  load average: 5,68, 2,91, 1,38
Tasks: 329 total,   2 running, 256 sleeping,   0 stopped,   1 zombie
%Cpu0 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu1 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu2 :100,0 us, 0,0 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st
%Cpu3 : 99,7 us, 0,3 sy, 0,0 ni, 0,0 id, 0,0 wa, 0,0 hi, 0,0 si, 0,0 st

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND     
 5850 batfai    20   0   68360    932    836 R 798,3  0,0   8:14.23 infty-f     
]]></screen>  
                                
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/lvmi6tyz-nI">https://youtu.be/lvmi6tyz-nI</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Ez a feladat a megállási probléma bemutatására szolgál. A megálláso problémea abból áll, hogy el lehet-e döntenti
            egy programról adott bemenet esetén, hogy végtelen ciklusba kerül-e. Alan Turin 1963-ban bizonyította be, hogy nem 
            lehetséges olyan álltalános algoritmust írni, amely minden program-bemenet párról megmondja, hogy végtelen ciklusba 
            kerül-e.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó(nbatfai): <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Változócserére több lehetőség is van, 4 féle alap módszer van. Ezek lehetnek:
            <itemizedlist>
              <listitem>
                <para>Segédváltozóval</para>   
              </listitem>
              <listitem>
                <para>Kivonással / Összeadással</para> 
              </listitem>
              <listitem>
                 <para>XOR logikai módszer</para>
              </listitem>
            </itemizedlist>
        </para>
        <para>
            Az első példára a segédváltozónak van jó és rossz oldala is. A jó oldala, hogy ez a legkönyebb mindközül logikailag 
          kitalálni és programba illetve pszeudokódba írni. A rossz oldala pedig a segédváltozó miatt van. A plusz változó miatt 
          több helyet kell lefoglalni.
            
            C beli leírása a következő:
        </para>
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
int main()
{
	int tmp = 0,a =1,b = 2;
	tmp = a;
	a = b;
	b = tmp;
}]]>    
        </programlisting> 
        <para>
            A  második példához a matematikailag ismert osszeadási és kivonási szabályokból ismeretes elemeket használjuk fel. Az egyik a következő:  
            a = a + b
            b = a - b
            a = a - b
            Lássuk végrehajtva. Az első lépésben a = 20 + 10 = 30 lesz. Utána b = 30 - 10 = 20, vagyis b-be máris bekerült a eredeti értéke,
            a harmadik lépésben pedig a = 30 - 20 = 10, puff, helyet cserélt a kettő!
            
            A másik ilyen módszer a következő:
            a = a - b
	          b = a + b
	          a = b - a
            Ezt is lássuk végrehajtva. Az első lépésben a = 20 - 10 = 10 lesz. Utána b = 10 + 10 = 20, vagyis b-be máris bekerült a eredeti értéke,
            a harmadik lépésben pedig a = 20 - 10 = 10, és így helyet cserélt a kettő!
            
            C beli leírása a következő:
        </para>
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
int main()
{
	int a =1,b = 2;
	a = a + b;
  b = a - b;
  a = a - b;
}]]>    
        </programlisting> 
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
int main()
{
	int a =1,b = 2;
	a = a - bé
  b = a + bé
  a = b - a;
}]]>    
        </programlisting> 
          <para>
           Az utoló módszerről pedig kicsit többet kell beszéljünk mivel az már egy kicsivel bonyolultabb, helytelen működésű és lassab. 
           
           Először nézzük, hogy mi is az az XOR csere:
              Annak idején, amikor még mindenki Assembly nyelvű programokat írt, rengeteg apró optimalizálást kézzel végeztek el a programozók. 
            Például egy regiszter nullázása helyett: movl $0, eax (C-ben: eax = 0), inkább saját magával XOR kapcsolatba hozták azt: xorl eax, eax (eax ^= eax). 
            Mert ez kevesebb bájtot foglalt, nem kellett a 0 számot eltárolni hozzá a memóriában. Akkoriban jöttek rá arra is, hogy két regiszter értékét szintén meg lehet 
            cserélni az xor gépi utasítással.
              A módszer előnye, hogy nincsen hozzá szükség segédregiszterre. Eddig minden rendben is lenne. A baj csak az, hogy a '70-es években kitalált, 
            az akkori szemléletet tükröző módszer annyira beszivárgott a köztudatba, hogy egyesek manapság is használják, magas szintű programozási nyelveken. 
            A XXI. században, amikor a fordítóprogramok legtöbbje gyorsabb kódot tud generálni, mint amilyen Assembly kódot az emberek írnának.
              
          Magával a módszerrel az a baj, hogy sok programozó nem értené mit akarunk ezzel a programrésszel valamint sokkal nehezebb megérteni, ezért nem terjedt el és nem is szokták
          használni viszont úgy éreztem jólenne bemutatni mivel ha valamilyen oknál fogva talalkoznál vele akkor tudd, hogy mi is ez pontosan és egy érdekességnek is elkönyvelhető.
              
            C beli leírása pedig a következő:
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
int main()
{
	int a =1,b = 2;
  a ^= b;
	b ^= a;
	a ^= b;
}]]>    
        </programlisting> 
        </para>
        <para>
              A tanulságnak levonhatjuk azt, hogy a segédváltozó segítségével a legkönyebb viszont a második módszerrel nem kell külön lefoglalni helyet a segédváltozónak. 
            Az XOR módszer pedig nem ajánlott használni a fenti okokból kifolyólag. Így a második módszert ajánlom használatra változócsere esetén.
        </para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó (nbatfai): <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Az if es megoldás C kódja:  
        </para>
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
#include <curses.h>
#include <unistd.h>

int main(void)
{
	WINDOW *window;
	window = initscr();
	int x=0, y=0;
	int xnow=1, ynow=1;
	int mx,my;
	for(;;)
	{
		getmaxyx(window,my,mx);
		mvprintw(y,x,"O");
		refresh();
		usleep(100000);
		clear();
		x=x+xnow;
		y=y+ynow;
		if (x>=mx-1) //Elerte-e a jobb oldalt?
		{
			xnow = xnow*-1;
		}
		if (x<=0) //Elerte-e a bal oldalt?
		{
			xnow = xnow*-1;
		}
		if (y<=0) //Elerte-e a tetejet?
		{
			ynow=ynow*-1;
		}
		if (y>=my-1) //Elerte-e az aljat?
		{
			ynow = ynow*-1;
		}
	}
	return 0;
}]]>    
        </programlisting> 
        <para>
            Az if nélküli megoldás C kódja:  
        </para>
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
#include <stdlib.h>
#include <curses.h>
#include <unistd.h>

int main(void)
{
	WINDOW *window;
	window = initscr();
	int xj=0, xk=0, yj=0, yk=0;
	int mx,my;
	nodelay(window, true);
	getmaxyx(window,my,mx);
	my=my*2;mx=mx*2;
	for(;;)
	{
		xj = (xj-1)%mx;
		xk = (xk+1)%mx;
		yj = (yj-1)%my;
		yk = (yk+1)%my;
		clear();
		mvprintw(abs((yj+(my-yk)) / 2),abs((xj+(mx-xk)) / 2), "O");
		refresh();
		usleep(100000);
	}
	return 0;
}]]>    
        </programlisting> 
        <para>
            A logikai változós megoldás könyen megoldható viszont enélkül eléggé megnehezítette a dolgomat. Végül sikerült megoldanom néhány érték atfésüléssel ahogy az a fenti példában
            is látható. Részletesebb magyarázatért megtekintheted a videót.
        </para>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó(nbatfai): <link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link>, 
            <link xlink:href="https://youtu.be/KRZlt1ZJ3qk">https://youtu.be/KRZlt1ZJ3qk</link>, 
            <link xlink:href=""/>.
        </para>
        <para>
            Megoldás forrása(nbatfai): <link xlink:href="Turing/bogomips.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Turing/bogomips.c</filename>
            </link>
        </para>
        <para>
            A megoldás C++ kódja:  
        </para>
        <programlisting language="c">
<![CDATA[
#include <iostream>
int main()
{
	int num = -1;
	int count = 0;
	unsigned int num_copy = (unsigned int)num;
	while(num_copy >>=1)
	{
		count++;
	}
	printf("%d",(count+1));
	return 0;
}]]>
        </programlisting> 
        <para>
            Először elég sokáig gondolkodtam, hogy a feladatban pontosan mit is kell csinálni mi is az amit kér. Egy barátom segítségével aki felsőbbéves rájöttem, innestől már elég 
            könyen ment a feladat megoldása és a meglévő algoritmus átírása.
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""/>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""/>
        </para>
        <para>
            A megoldás C kódja:  
        </para>
        <programlisting language="c">
<![CDATA[
#include <stdio.h>
#include <math.h>

void kiir (double tomb[], int db)
{
	int i;
	for (i=0; i<db; i++)
	printf("%lf\n", tomb[i]);
}
double tavolsag(double pagerank[],double pagerank_temp[],int db)
{
	double tav = 0.0;
	int i;
	for(i=0;i<db;i++)
		tav+=(pagerank[i] - pagerank_temp[i])*(pagerank[i] - pagerank_temp[i]);
	sqrt(tav);
	return tav;
}
int main(void)
{
	double L[4][4] = {
		{0.0, 0.0, 1.0 / 3.0, 0.0},
		{1.0, 1.0 / 2.0, 1.0 / 3.0, 1.0},
		{0.0, 1.0 / 2.0, 0.0, 0.0},
		{0.0, 0.0, 1.0 / 3.0, 0.0}
	};
	double PR[4] = {0.0, 0.0, 0.0, 0.0};
	double PRv[4] = {1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0, 1.0 / 4.0};
	for (;;) 
	{
		for(int i=0;i<4;i++)
		{
			PR[i]=0;
			for (int j=0;j<4;j++)
			{    
				 PR[i] = PR[i]+(PRv[j]*L[i][j]);
			}
		}
		if ( tavolsag(PR,PRv, 4) < 0.00000001)
			break;
		for(int i=0;i<4;i++)
			PRv[i]=PR[i];
	}
	kiir (PR,4);
	return 0;
} ]]>
        </programlisting> 
        <para>
            Mivel pagerank ot már sikerült megírjam egyszer C++-ban így az átírás könyedén megoldható volt. 
        </para>
    </section>
                                                                                                                                                                                                                                                                                                                                                        
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó(nbatfai): <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása(nbatfai): <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <programlisting language="R">
<![CDATA[
kis_szam=10000000
kis=sample(1:3,kis_szam,replace=T)
jatekos=sample(1:3,kis_szam,replace=T)
vezeto=vector(length=kis_szam)
for(i in 1:kis_szam)
{
	if(kis[i]==jatekos[i])
	{
		mibol=setdiff(c(1,2,3),kis[i])
	}
	else
	{
		mibol=setdiff(c(1,2,3),c(kis[i],jatekos[i]))
	}
	vezeto[i]=mibol[sample(1:length(mibol),1)]
}
nemvaltnyer=which(kis==jatekos)
valt=vector(length=kis_szam)
for(i in 1:kis_szam)
{
	holvaltoztat=setdiff(c(1,2,3),c(vezeto[i],jatekos[i]))
	valt[i]=holvaltoztat[sample(1:length(holvaltoztat),1)]
}
valtnyer=which(kis==valt)
sprintf("Kiserletek szama: %i",kis_szam)
length(nemvaltnyer)
length(valtnyer)
length(nemvaltnyer)/length(valtnyer)
length(nemvaltnyer)+length(valtnyer)
]]>
        </programlisting> 
        <para>
            Őszintén megvallva életemben nem hallodtam a Monty Hall problémáról eddig. Viszont informálódva Bátfai anyagaiból  hamar megtudtam érteni a lényegét és
            összerakni a szimulációt. Igaz magáról az R nyelvről sem hallodtam de ahogy az alapjait kezdtem nézni be kell valjam nem nehéz nyelv valamitn nem valami elterjedt
            a használata. 
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó(nbatfai): <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása(nbatfai): <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>

        <para>
            A természetes számok építőelemei a prímszámok. Abban az értelemben, 
            hogy minden természetes szám előállítható prímszámok szorzataként.
            Például 12=2*2*3, vagy például 33=3*11.
        </para>
        <para>
            Prímszám az a természetes szám, amely csak önmagával és eggyel 
            osztható. Eukleidész görög matematikus már Krisztus előtt tudta, 
            hogy végtelen sok prímszám van, de ma sem tudja senki, hogy 
            végtelen sok ikerprím van-e. Két prím ikerprím, ha különbségük 2.
        </para>
        <para>
            Két egymást követő páratlan prím között a legkisebb távolság a 2, 
            a legnagyobb távolság viszont bármilyen nagy lehet! Ez utóbbit 
            könnyű bebizonyítani. Legyen n egy tetszőlegesen nagy szám. 
            Akkor szorozzuk össze n+1-ig a számokat, azaz számoljuk ki az 
            1*2*3*… *(n-1)*n*(n+1) szorzatot, aminek a neve (n+1) faktoriális, 
            jele (n+1)!.
        </para>
        <para>
            Majd vizsgáljuk meg az a sorozatot:
        </para>    
        <para>
            (n+1)!+2, (n+1)!+3,… , (n+1)!+n, (n+1)!+ (n+1) ez n db egymást követő azám, ezekre (a jól ismert
            bizonyítás szerint) rendre igaz, hogy            
        </para>    
        <itemizedlist>
            <listitem>
                <para>(n+1)!+2=1*2*3*… *(n-1)*n*(n+1)+2, azaz 2*valamennyi+2, 2 többszöröse, így ami osztható kettővel</para>
            </listitem>
            <listitem>
                <para>(n+1)!+3=1*2*3*… *(n-1)*n*(n+1)+3, azaz 3*valamennyi+3, ami osztható hárommal</para>
            </listitem>
            <listitem>
                <para>...</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n-1)=1*2*3*… *(n-1)*n*(n+1)+(n-1), azaz (n-1)*valamennyi+(n-1), ami osztható (n-1)-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+n=1*2*3*… *(n-1)*n*(n+1)+n, azaz n*valamennyi+n-, ami osztható n-el</para>
            </listitem>
            <listitem>
                <para>(n+1)!+(n+1)=1*2*3*… *(n-1)*n*(n+1)+(n+1), azaz (n+1)*valamennyi+(n+1), ami osztható (n+1)-el</para>
            </listitem>
        </itemizedlist>
        <para>
            tehát ebben a sorozatban egy prim nincs, akkor a (n+1)!+2-nél 
            kisebb első prim és a (n+1)!+ (n+1)-nél nagyobb első 
            prim között a távolság legalább n.            
        </para>    
        <para>
            Az ikerprímszám sejtés azzal foglalkozik, amikor a prímek közötti 
            távolság 2. Azt mondja, hogy az egymástól 2 távolságra lévő prímek
            végtelen sokan vannak.
        </para>    
        <para>
            A Brun tétel azt mondja, hogy az ikerprímszámok reciprokaiból képzett sor összege, azaz
            a (1/3+1/5)+ (1/5+1/7)+ (1/11+1/13)+... véges vagy végtelen sor konvergens, ami azt jelenti, hogy ezek
            a törtek összeadva egy határt adnak ki pontosan vagy azt át nem lépve növekednek, 
            ami határ számot B<subscript>2</subscript> Brun konstansnak neveznek. Tehát ez
            nem dönti el a több ezer éve nyitott kérdést, hogy az ikerprímszámok halmaza végtelen-e? 
            Hiszen ha véges sok van és ezek
            reciprokait összeadjuk, akkor ugyanúgy nem lépjük át a B<subscript>2</subscript> Brun konstans értékét, 
            mintha végtelen 
            sok lenne, de ezek már csak olyan csökkenő mértékben járulnának hozzá a végtelen sor összegéhez, 
            hogy így sem lépnék át a Brun konstans értékét.     
        </para>
        <para>
            Ebben a példában egy olyan programot készítettünk, amely közelíteni próbálja a Brun konstans értékét.
            A repó <link xlink:href="../../../bhax/attention_raising/Primek_R/stp.r">
                <filename>bhax/attention_raising/Primek_R/stp.r</filename>
            </link> mevű állománya kiszámolja az ikerprímeket, összegzi
            a reciprokaikat és vizualizálja a kapott részeredményt.
        </para>
        <programlisting language="R">
<![CDATA[#   Copyright (C) 2019  Dr. Norbert Bátfai, nbatfai@gmail.com
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>

library(matlab)

stp <- function(x){

    primek = primes(x)
    differencia = primek[2:length(primes)]-primek[1:length(primes)-1]
    index = which(differencia==2)
    v1primek = primek[idx]
    v2primek = primek[idx]+2
    v1pv2 = 1/v1primek+1/v2primek
    return(sum(v1pv2))
}

x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")
]]>
        </programlisting>        
        <para>
            Soronként értelemezzük ezt a programot:
        </para>                
        <programlisting language="R">
<![CDATA[ primek = primes(13)]]>
        </programlisting>        
        <para>
            Kiszámolja a megadott számig a prímeket.             
        </para>
        <screen>
<![CDATA[> primek=primes(13)
> primek
[1]  2  3  5  7 11 13
]]>
        </screen>
                
        <programlisting language="R">
<![CDATA[ diff = primek[2:length(primes)]-primek[1:length(primek)-1]]]>
        </programlisting>        
        <screen>
<![CDATA[> diff = primek[2:length(primes)]-primek[1:length(primek)-1]
> differencia
[1] 1 2 2 4 2
]]>
        </screen>        
        <para>
            Az egymást követő prímek különbségét képzi, tehát 3-2, 5-3, 7-5, 11-7, 13-11.
        </para>
        <programlisting language="R">
<![CDATA[index = which(diff==2)]]>
        </programlisting>        
        <screen>
<![CDATA[> index = which(diff==2)
> index
[1] 2 3 5
]]>
        </screen>              
        <para>
            Megnézi a <varname>differencia</varname>-ban, hogy melyiknél lett kettő az eredmény, mert azok az ikerprím párok, ahol ez igaz.
            Ez a <varname>differencia</varname>-ban lévő 3-2, 5-3, 7-5, 11-7, 13-11 külünbségek közül ez a 2., 3. és 5. indexűre teljesül.
        </para>
        <programlisting language="R">
<![CDATA[v1primek = primek[index]]]>
        </programlisting>  
        <para>
            Kivette a primes-ból a párok első tagját. 
        </para>
        <programlisting language="R">
<![CDATA[v2primek = primek[index]+2]]>
        </programlisting>        
        <para>
            A párok második tagját az első tagok kettő hozzáadásával képezzük.
        </para>
        <programlisting language="R">
<![CDATA[rt1plust2 = 1/t1primes+1/t2primes]]>
        </programlisting>        
        <para>
            Az 1/v1primek a v1primek 3,5,11 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/v1primek
[1] 0.33333333 0.20000000 0.09090909
]]>
        </screen>                      
        <para>
            Az 1/v2primek a v2primek 5,7,13 értékéből az alábbi reciprokokat képzi:
        </para>
        <screen>
<![CDATA[> 1/v2primek
[1] 0.20000000 0.14285714 0.07692308
]]>
        </screen>                      
        <para>
            Az 1/v1primek + 1/v2primek pedig ezeket a törteket rendre összeadja.
        </para>
        <screen>
<![CDATA[> 1/t1primes+1/t2primes
[1] 0.5333333 0.3428571 0.1678322
]]>
        </screen>                      
        <para>
            Nincs más dolgunk, mint ezeket a törteket összeadni a 
            <function>sum</function> függvénnyel.
        </para>
        
        <programlisting language="R">
<![CDATA[sum(rt1plust2)]]>
        </programlisting>    
        <screen>
<![CDATA[>   sum(rt1plust2)
[1] 1.044023
]]>
        </screen>            
        <para>
            A következő ábra azt mutatja, hogy a szumma értéke, hogyan nő, egy határértékhez tart, a 
            B<subscript>2</subscript> Brun konstanshoz. Ezt ezzel a csipettel rajzoltuk ki, ahol először a fenti 
            számítást 13-ig végezzük, majd 10013, majd 20013-ig, egészen 990013-ig, azaz közel 1 millióig.
            Vegyük észre, hogy az ábra első köre, a 13 értékhez tartozó 1.044023.
        </para>
        <programlisting language="R">
<![CDATA[x=seq(13, 1000000, by=10000)
y=sapply(x, FUN = stp)
plot(x,y,type="b")]]>
        </programlisting>          
        <figure>
            <title>A B<subscript>2</subscript> konstans közelítése</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/BrunKorok.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A B<subscript>2</subscript> konstans közelítése</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <tip>
            <title>Werkfilm</title>
            <itemizedlist>
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/VkMFrgBhN1g">https://youtu.be/VkMFrgBhN1g</link>
                    </para>    
                </listitem>                
                <listitem>
                    <para>
                        <link xlink:href="https://youtu.be/aF4YK6mBwf4">https://youtu.be/aF4YK6mBwf4</link>
                    </para>    
                </listitem>                
            </itemizedlist>                
        </tip>
    </section>

</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Decimálisból unárisba átváltó Turing gép</title>
        <para>
            Állapotátmenet gráfjával megadva írd meg ezt a gépet!
        </para>
        <para>
            A megoldáshoz tartozik egy kód, amit konyen lehet vizualizálni és futtatni a kobvetkező linken: <link href="https://turingmachine.io/">https://turingmachine.io/</link>

          A kód pedig a követekező:
          <programlisting >
            <![CDATA[%{
#https://turingmachine.io/
input: '12'
blank: ' '
start state: GoRight
table:
  # scan to the rightmost digit
  GoRight:
    [0,1,2,3,4,5,6,7,8,9]: R
    ' '  : {L: Decrease}
    
  Decrease:
    ' ': {R: done}
    0: {L: 0ism}
    1: {write: 0, R: ToUniStartP}
    2: {write: 1, R: ToUniStartP}
    3: {write: 2, R: ToUniStartP}
    4: {write: 3, R: ToUniStartP}
    5: {write: 4, R: ToUniStartP}
    6: {write: 5, R: ToUniStartP}
    7: {write: 6, R: ToUniStartP}
    8: {write: 7, R: ToUniStartP}
    9: {write: 8, R: ToUniStartP}
    
  ToUniStartP:
    [0,1,2,3,4,5,6,7,8,9]: R
    ' '  : {R: ToUniEndP}
    
  ToUniEndP:
    1: R
    ' ': {write: 1, L: ToDecimalStartP}
    
  ToDecimalStartP:
    1: L
    ' ': {L: Decrease}
    
  0ism:
    0: {L: 0ism}
    ' ': {R: done}
    1: {write: 0, R: TENmONE}
    2: {write: 1, R: TENmONE}
    3: {write: 2, R: TENmONE}
    4: {write: 3, R: TENmONE}
    5: {write: 4, R: TENmONE}
    6: {write: 5, R: TENmONE}
    7: {write: 6, R: TENmONE}
    8: {write: 7, R: TENmONE}
    9: {write: 8, R: TENmONE}
    
  TENmONE:
    0: {write: 9, R: TENmONE}
    ' ': {L: ToUniStartP}
  done:
}
]]>
          </programlisting>
        </para>
      <para>
      A C beni átírása pedig a következő:  
      </para>
      <programlisting language="c">
        <![CDATA[
#include <stdio.h>
int main()
{
	int a, db=0;
	printf("Adjon meg egy decimalis szamot!\n");
	scanf("%d", &a);
	printf("A megadott szam unarisba atvaltva:\n");
	for (int i = 0; i < a; i++)
	{
		printf("|");
		db++;
		if (db % 5 == 0) 
                {
                	printf(" ");
                }
	}
	printf("\n");
	return 0;
}]]>
      </programlisting>
      
        <para>
          A turing gép vizualizációja:
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/TuringDecimalTOUniral.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>Decimal to Uniral turing gép</phrase>
                </textobject>
            </mediaobject>
        </para>
        <para>
            Megoldás videó: (Hamarosan)
        </para>
        <para>
            Megoldás forrása:   (hamarosan)             
        </para>
        <para>
          Ilyen tárgyunk ahol ezzel részletesebben foglalkoztunk volna még nem volt, de a Turing-gép elég egyszerűnek bizonyult ahhoz hogy előzetes tudás nélkül egy online eszköz használatával megírjam a programot.
        </para>
        <para>
          Megéri belekezdeni egy olyan feladatba is amiről előzetesen semmit sem tudunk, mert lehet könnyen megérthető és egyszerűbb, mint gondolnánk. Előre eléggé szkeptikus voltam de kicsi áskálás után már világossá és könyuvé vállt.
          
          A tanulást sok online eszköz is elősegíti. Én ezt az állapotátmenet-gráfot a <link xlink:href="https://turingmachine.io/">turingmachine.io</link> segítségével írtam, ami egy egyszerű basic-szerű scriptnyelvből tud turing-gépeket generálni és szép grafikákat is csinálni hozzá.
        </para>        
    </section>        
    <section>
        <title>Az a<superscript>n</superscript>b<superscript>n</superscript>c<superscript>n</superscript> nyelv nem környezetfüggetlen</title>
        <para>
            Mutass be legalább két környezetfüggő generatív grammatikát, amely ezt a nyelvet generálja!
        </para>
        <para>      
        A generatív gramatika Noam Chomsky nevéhez kötődik. Úgy vizsgálja a nyelvtant mint az ismeret alapját, hiszen ha
            nem lenne nyelvtanunk, akkor a tudást nem tudnánk se megörökíteni, se továbbadni. Nézete azt a vállotta, hogy a tudás 
            és az ismeret többnyire öröklött (generációról generációra terjed), vagyis univerzális (gondolván a gyerekekre, akik 
            könnyedén elsajátítják anyanyelvüket). A generatív gramatikának négy fő része van: nemterminális jelek, terminális jelek, 
            helyettesítési/képzési szabályok és mondat/kezdő szimbólumok, illetve három nyelvtan fajtája: környezetfüggő, környezetfüggetlen 
            és reguláris. Nézzünk meg két példát környezetfüggő leírásra (a nyilak jelölik majd a képzési szabályokat)
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <programlisting>
<![CDATA[
S, X, Y: „változók” (a nemterminálisok)
a, b, c: „konstansok” (a terminálisok)
S → abc, S → aXbc, Xb → bX, Xc → Ybcc, bY → Yb, aY -> aaX, aY → aa (a helyettesítési szabályok)
S (a mondatszimbólum)

    S (S → aXbc)
    aXbc (Xb → bX)
    abXc (Xc → Ybcc)
    abYbcc (bY → Yb)
    aabbcc

    S (S → aXbc)
    aXbc (Xb → bX)
    abXc (Xc → Ybcc)
    abYbcc (bY → Yb)
    aYbbcc (aY -> aaX)
    aaXbbcc (Xb → bX)
    aabXbcc (Xb → bX)
    aabbXcc (Xc → Ybcc)
    aabbYbccc (bY → Yb)
    aabYbbccc (bY → Yb)
    aaYbbbccc (aY → aa)
    aaabbbccc]]> 
        </programlisting>
        
        <programlisting>
<![CDATA[
A, B, C: „változók” (a nemterminálisok)
a, b, c: „konstansok” (a terminálisok)
A → aAB, A → aC, CB → bCc, cB → Bc, C → bc (a képzési szabályok) 
S (A kezdőszimbólum)

    A (A → aAB)
    aAB ( A → aC)
    aaCB (CB → bCc)
    aabCc (C → bc)
    aabbcc

    A (A → aAB)
    aAB ( A → aAB)
    aaABB ( A → aAB)
    aaaABBB ( A → aC)
    aaaaCBBB (CB → bCc)
    aaaabCcBB (cB → Bc)
    aaaabCBcB (cB → Bc)
    aaaabCBBc (CB → bCc)
    aaaabbCcBc (cB → Bc)
    aaaabbCBcc (CB → bCc)
    aaaabbbCccc (C → bc)
    aaaabbbbcccc]]> 
        </programlisting>

      <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
                
    <section>
        <title>Hivatkozási nyelv</title>
        <para>
            A <citation>KERNIGHANRITCHIE</citation> könyv C referencia-kézikönyv/Utasítások melléklete alapján definiáld 
            BNF-ben a C utasítás fogalmát!
            Majd mutass be olyan kódcsipeteket, amelyek adott szabvánnyal nem fordulnak (például C89), mással (például C99) igen.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
      <programlisting>
        <![CDATA[
<utasítás>	::=	<címkézett> | <kifejezés> | <összetett> | <kiválasztó> | <iterációs> | <vezértlésátadó>

<címkézett>	::=	azonosító : <utasítás>
				        case <állandó_kif> : <utasítás>
				        default : <utasítás>

<kifejezés>	::=	<kifejezés_kif> ;

<összetett>	::=	{deklarációs_lista utasítás_lista}
	
	<deklarációs_lista>	::=	deklaráció
							            deklarációs_lista deklaráció
	<utasítás_lista>	::=	utasítás
							          utasítás_lista utasítás

<kiválasztó>	::=	if ( <kifejezés_kif> ) <utasítás>
					        if ( <kifejezés_kif> ) <utasítás> else <utasítás>
					        switch ( kifeje
					        zés_kif ) <utasítás>

<iterációs>	::=	while ( <kifejezés_kif> ) <utasítás>
				        do  <utasítás> while ( <kifejezés_kif> ) ;
				        for (<kifejezés_kif> ; <kifejezés_kif> ; <kifejezés_kif> ) <utasítás>

<vezérlésátadó>	::=	goto <azonosító> ;
					          continue ;
					          break ;
					          return <kifejezés_kif> ;
]]>
      </programlisting>

      <para>
        Valamint a C kód:
      </para>
      <programlisting language="c">
        <![CDATA[
#include "stdio.h"

int main()
{
	//c99+
	for (int i = 0; i<5; i++)
	{
		long long int a = 5;
	}

	char* a;

	//c11-
	gets(a);

	return 0;}]]>
      </programlisting>
    </section>                     

    <section>
        <title>Saját lexikális elemző</title>
        <para>
            Írj olyan programot, ami számolja a bemenetén megjelenő valós számokat! 
            Nem elfogadható olyan megoldás, amely maga olvassa betűnként a bemenetet, 
            a feladat lényege, hogy lexert használjunk, azaz óriások vállán álljunk és ne kispályázzunk!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://youtu.be/9KnMqrkj_kU">https://youtu.be/9KnMqrkj_kU</link> (15:01-től).
        </para>
        <para>
            A lexer egy olyan program amelyik megír, összeállít nekünk egy C programot. A lex programok úgymond több részből tevődnek össze, ezeket a részeket %%-al vannak elválasztva egymástól.
            A mi programunk most 3 részből áll. A programot ezen részletek alapján viszgáljuk meg.
        </para>
        <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Chomsky/realnumber.l">../Chomsky/realnumber.l</link>   
        </para> 
        <programlisting language="c"><![CDATA[%{
#include <stdio.h>
int realnumbers = 0;
%}
digit  	[0-9]
%%]]>
        </programlisting>
        <para>
            A kapcsoszárójelek közötti részt a lexer, úgy ahogy van egy az egyben berakja a C programba. Az első része ismerős a C kódokból, 
            az <command>include</command>-dal deklaráljuk az stdio header fájlt. Ezután egy deklarálás és egyben egy értékadás jön 
            (a <varname>realnumber</varname> változó kezdetben a 0-ás értéket kapja). A a <varname>realnumber</varname> változóval azt számoljuk majd, 
            hogy hány számot olvas be a program. A kapcsoszárójelezett rész után jönnek a definíciók, a mi esetünkben is van egy: a <varname>digit</varname> 
            nevű definícióval egy szám csoportot adunk meg (0-tól 9-ig tartalmazza a számokat, tehát a számjegyeket tárolja). Szögletes zárójelek között egy 
            karaktereket tudunk megadni, de mi most mivel számokat irtunk közé, ezért nem karaktereket, hanem számokat fog tárolni. Majd mindezek után, %%-al
            lezárjuk ezt a részt.
        </para>
        
        <programlisting language="c"><![CDATA[
{digit}*(\.{digit}+)?	{++realnumbers; 
    printf("[realnum=%s %f]", yytext, atof(yytext));}
%%]]>
        </programlisting>
        <para>
            Ebben, a második részben, jelennek meg a fordítási szabályok, ahol már használjuk is a definícióknál megadottakat, tehát egyfajta 
            használati utasítást adunk meg hozzjuk. A <command>{digit}*</command> azt jelenti, hogy a digitből lehet nulla vagy bármennyi darab. 
            Az informatikában a "." karakter magában azt jelenti, hogy amit szeretnlnk azt bármilyen karakterre rá lehet illeszteni. De mivel 
            mi most a lexel azt akarjuk elérni, hogy tokeneket, valós számokat ismerjen fel (tehát olyan formájú számokat, mint például a 3.5, 
            vagyis szám.szám), ezért a "."-ot le kell védeni, amit a / jel segítségével érjük el. A levédett pont után egy újabb kifejezés következik 
            (<command>{digit}+</command>), ami azt takarja hogy a pont után is számjegyek jönnek, bármennyi de legalabb egy mindenképp (+). Ha ez a 
            leírás megegyezik az egyik intup adattal, tehát ha talál egy ilyet, akkor (jön egy utasítássorozat ami {}-ek közé van téve) növeli a 
            <varname>realnumber</varname> értékét, és ezt kiírja a képernyőre először stringkét (%s), melyet el is tárolunk az yytext-be, majd számként 
            kiiratjuk (%f), az <function>atof</function> függvénnyel az <varname>yytext</varname>-ben lévő stringet átkonvertáljuk double típusú számmá.
        </para>
        
        <programlisting language="c"><![CDATA[int
main ()
{
 yylex ();
 printf("The number of real numbers is %d\n", realnumbers);
 return 0;
}]]>
        </programlisting>
        <para>
            Az utolsó rész pedig már úgymond maga a tényleges program, ahol meghívjuk az előbb definiált lexikális <function>yylex</function> függvényt, 
            elemzést és miután ez véget ér, akkor kiiratom a valós számok számát, vagyis a <varname>realnumber</varname> értékét.
        </para>
        <para>
            C forráskód létrehozása: <command>lex -o realnumber.c realnumber.l</command>
        </para>
        <para>
            Fordítás: <command>gcc realnumber.c -o realnumber -lfl</command> 
        </para>
        <para>
            Futtatás: <command>./realnumber</command>
        </para>
        
    </section>
                     

    <section>
        <title>Leetspeak</title>
        <para>
            Lexelj össze egy l33t ciphert!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/06C_PqDpD_k">https://youtu.be/06C_PqDpD_k</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Chomsky/l337d1c7.l">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Chomsky/l337d1c7.l</filename>
            </link>  
        </para>
      <para> 
            A forráskód megtalálható a következő linken is: <link xlink:href="Chomsky/3.5/l33tsp3ak.l">../Chomsky/l33tsp3ak.l</link>   
        </para>

        <programlisting language="c"><![CDATA[%{
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  #include <ctype.h>

  #define L337SIZE (sizeof l337d1c7 / sizeof (struct cipher))
    
  struct cipher {
    char c;
    char *leet[4];
  } l337d1c7 [] = {

  {'a', {"4", "4", "@", "/-\\"}},
  {'b', {"b", "8", "|3", "|}"}},
  {'c', {"c", "(", "<", "{"}},
  {'d', {"d", "|)", "|]", "|}"}},
  {'e', {"3", "3", "3", "3"}},
  {'f', {"f", "|=", "ph", "|#"}},
  {'g', {"g", "6", "[", "[+"}},
  {'h', {"h", "4", "|-|", "[-]"}},
  {'i', {"1", "1", "|", "!"}},
  {'j', {"j", "7", "_|", "_/"}},
  {'k', {"k", "|<", "1<", "|{"}},
  {'l', {"l", "1", "|", "|_"}},
  {'m', {"m", "44", "(V)", "|\\/|"}},
  {'n', {"n", "|\\|", "/\\/", "/V"}},
  {'o', {"0", "0", "()", "[]"}},
  {'p', {"p", "/o", "|D", "|o"}},
  {'q', {"q", "9", "O_", "(,)"}},
  {'r', {"r", "12", "12", "|2"}},
  {'s', {"s", "5", "$", "$"}},
  {'t', {"t", "7", "7", "'|'"}},
  {'u', {"u", "|_|", "(_)", "[_]"}},
  {'v', {"v", "\\/", "\\/", "\\/"}},
  {'w', {"w", "VV", "\\/\\/", "(/\\)"}},
  {'x', {"x", "%", ")(", ")("}},
  {'y', {"y", "", "", ""}},
  {'z', {"z", "2", "7_", ">_"}},
  
  {'0', {"D", "0", "D", "0"}},
  {'1', {"I", "I", "L", "L"}},
  {'2', {"Z", "Z", "Z", "e"}},
  {'3', {"E", "E", "E", "E"}},
  {'4', {"h", "h", "A", "A"}},
  {'5', {"S", "S", "S", "S"}},
  {'6', {"b", "b", "G", "G"}},
  {'7', {"T", "T", "j", "j"}},
  {'8', {"X", "X", "X", "X"}},
  {'9', {"g", "g", "j", "j"}}
  
// https://simple.wikipedia.org/wiki/Leet
  };
  
%}
%%
]]></programlisting>
        <para>
            Pont úgy, mint az előző lexiális elemző feladatban, a program szerkezete, felépítése úgyanaz (a három fő rész). Először is 
            megadjuk a header fájloka, majd szintén következnek a definíciók. A definícióknál deklarálunk egy <varname>L337SIZE</varname>-ot,
            ami segítségével meg tudjuk majd határozni az input hosszát. Egy struktúra segítségével 
            létrehozzuk a ciphert ami megkapja a karaktert (amit majd átír), illetve a négy lehetőséget, stringet (amire majd cseréli). 
            Majd ebből a struktúrából létrehozunk egy <varname>l337d1c7</varname> nevű tömbböt (nem adjuk meg az elemeit, azt majd a program 
            megszámol magának), aminek be is adagoljuk az elemeit a struktúra felépítettsége szerint (először a latin betű, majd pedig 
            a négy lehetőség amire cserélheti a program). Ezzek vége is az program első részének.
        </para>

        <programlisting language="c">
<![CDATA[.	{
	  int found = 0;
	  for(int i=0; i<L337SIZE; ++i)
	  {
	  
	    if(l337d1c7[i].c == tolower(*yytext))
	    {
	    
	      int r = 1+(int) (100.0*rand()/(RAND_MAX+1.0));
	    
          if(r<91)
	        printf("%s", l337d1c7[i].leet[0]);
          else if(r<95)
	        printf("%s", l337d1c7[i].leet[1]);
	      else if(r<98)
	        printf("%s", l337d1c7[i].leet[2]);
	      else 
	        printf("%s", l337d1c7[i].leet[3]);

	      found = 1;
	      break;
	    }
	    
	  }
	  
	  if(!found)
	     printf("%c", *yytext);	  
	  
	}
%%]]>
        </programlisting>
        <para>
            A második részben egy for ciklussal végig megyünk a kapott inputon. Az i-edig (tehár majd rendre mindegyik) 
            latin karaktert átalakítja kisbetűvé, megkeresi az adott listában, random számot generál neki (körülbelül 0-100 közöttit), 
            majd az if résznél lévő vizsgálatok alapján (a random számot vizsgálva) dönti el hogy a latin betűnek melyik megfelelőjét írja 
            ki a négy közül. Ha a random szám kisebb mint 91, akkor az első karaktert választja (az elsőnek a legnagyobb a valószínűsége), 
            ha 91 és 94 közötti, akkor a második lehetőséget, ha 94 és 97 közötti, akkor harmadik lehetőséget, ha pedig 97-től nagyobb, akkor
            az utolsó karaktert választja és írja ki.
        </para>

        <programlisting language="c">
<![CDATA[int 
main()
{
  srand(time(NULL)+getpid());
  yylex();
  return 0;
}
]]>
        </programlisting>
        <para>
            A program harmadik és egyben utolsó része egy c programrészlet, ahol a <function>yylex()</function> 
            függvényhívással elindítjuk az input átváltoztatását.
        </para>
        <para>
            C forráskód létrehozása: <command>lex -o l33tsp3ak.c l33tsp3ak.l</command>
        </para>
        <para>
            Fordítás: <command>gcc l33tsp3ak.c -o l33tsp3ak -lfl</command> 
        </para>
        <para>
            Futtatás: <command>./l33tsp3ak</command>
        </para>

    </section>                     


    <section>
        <title>A források olvasása</title>
        <para>
            Hogyan olvasod, hogyan értelmezed természetes nyelven az alábbi kódcsipeteket? Például
            <programlisting><![CDATA[if(signal(SIGINT, jelkezelo)==SIG_IGN)
    signal(SIGINT, SIG_IGN);]]></programlisting>
            Ha a SIGINT jel kezelése figyelmen kívül volt hagyva, akkor ezen túl is legyen
            figyelmen kívül hagyva, ha nem volt figyelmen kívül hagyva, akkor a jelkezelo függvény
            kezelje. (Miután a <command>man 7 signal</command> lapon megismertem a SIGINT jelet, a
            <command>man 2 signal</command> lapon pedig a használt rendszerhívást.)
        </para>

        <caution>
            <title>Bugok</title>
            <para>
                Vigyázz, sok csipet kerülendő, mert bugokat visz a kódba! Melyek ezek és miért? 
                Ha nem megy ránézésre, elkapja valamelyiket esetleg a splint vagy a frama?
            </para>
        </caution>
            
        <orderedlist numeration="lowerroman">
          <listitem>
            <programlisting><![CDATA[for(i=0; i<5; ++i)]]></programlisting>
            <para>
              Először i-t 0-val tesszük egyenlővé. Ezután megnézzük, hogy i kisebb-e mint 5.
              Ha igen, akkor lefuttatjuk a body-t majd inkrementáljuk i-t.
              Ha nem, akkor tovább haladunk a következő utasításhoz
            </para>
          </listitem>
          <listitem>
            <programlisting><![CDATA[for(i=0; i<5; i++)]]></programlisting>
            <para>
              Először i-t 0-val tesszük egyenlővé. Ezután megnézzük, hogy i kisebb-e mint 5.
              Ha igen, akkor lefuttatjuk a body-t majd inkrementáljuk i-t.
              Ha nem, akkor tovább haladunk a következő utasításhoz
            </para>
            <para>
              A post-vagy pre-inkrementálás különbsége itt teljesen mindegy, mivel nem használjuk a visszadott értéket és a tévhittel ellenben ugyanannyi instrukciót generál (ugyanolyan "gyors") mindkettő.
            </para>
          </listitem>
            <listitem>
              <programlisting><![CDATA[for(i=0; i<5; tomb[i] = i++)]]></programlisting>
              <para>
                Először i-t 0-val tesszük egyenlővé. Ezután megnézzük, hogy i kisebb-e mint 5.
                Ha igen, akkor lefuttatjuk a body-t majd a tomb[i]-t egyenlővé tesszük i-vel, ezután inkrementáljuk i-t.
                Ha nem, akkor tovább haladunk a következő utasításhoz
              </para>
            </listitem>
            <listitem>
              <programlisting><![CDATA[for(i=0; i<n && (*d++ = *s++); ++i)]]></programlisting>
              <para>
                s-ből d-be n elemet másol.
              </para>
            </listitem>
            <listitem>
              <programlisting><![CDATA[printf("%d %d", f(a, ++a), f(++a, a));]]></programlisting>
              <para>
                Unspecified behaviour. (Mert a függvényargumentumok kiértékelési sorrendje nincs meghatározva.)
                Természetes nyelven: Mindhárom függvényhívás kiértékelődik, de nem tudjuk milyen sorrendben értékelődnek ki az argumentumok.
              </para>
            </listitem>
            <listitem>
              <programlisting><![CDATA[printf("%d %d", f(a), a);]]></programlisting>
              <para>
                Kiírja az f(a)-t integerként és az a-t integerként. Itt azért nincs baj mert a-t másoljuk mikor meghívjuk f-et, tehát a eredeti értéke nem változik.
              </para>
            </listitem>
            <listitem>
              <programlisting><![CDATA[printf("%d %d", f(&a), a);]]></programlisting>
              <para>
                Ha a-t módosítjuk f-ben akkor mivel nincs meghatározva a kiértékelési sorrend, ezért az a lehet a módosítatlan a is vagy a módosított is.
              </para>
            </listitem>
          </orderedlist>
        <para>
            Megoldás forrása:  
        </para>

        <para>
            Megoldás videó: 
        </para>

        <para>
          Egy kis gyakorlás C ből. Valamint, hogy legyen fogalmunk mi mit csinál és hogyan. Megtudtam milyen jó dolgunk van manapság a c++ auto-val,
          ami kitalálja helyettünk a típust, valamint a template-ekkel amik segítségével nem is kell foglalkoznunk a funkciók pontos definíciójával.
          
        </para>

    </section>                     

    <section>
        <title>Logikus</title>
        <para>
            Hogyan olvasod természetes nyelven az alábbi Ar nyelvű formulákat?
        </para>
        <programlisting language="tex"><![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$ 

$(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ 

$(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ 

$(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$
]]></programlisting>        
      <programlisting language="tex">
<![CDATA[$(\forall x \exists y ((x<y)\wedge(y \text{ prím})))$]]>
        </programlisting> 
        <para>
            Minden valós szám estén létezik egy másik olyan valós szám, ami nagyobb tőle és prím (tehát minden számtól
            van nagyobb prím).
        </para>

        <programlisting language="tex">
<![CDATA[ $(\forall x \exists y ((x<y)\wedge(y \text{ prím})\wedge(SSy \text{ prím})))$ ]]>
        </programlisting>
        <para>
            Minden valós szám esetén létezik egy másik olyan valós szám ami nagyobb tőle, prím és a tőle kettővel 
            nagyobb valós szám is prímszám (tehát véges sok ikerprím van). 
        </para> 

        <programlisting language="tex">
<![CDATA[ $(\exists y \forall x (x \text{ prím}) \supset (x<y)) $ ]]>
        </programlisting>
        <para>
            Létezik olyan y valós szám minden x valós szám esetén, hogy ha az x prímszám, 
            akkor az x kisebb mint az y (tehát véges sok prímszám van).
        </para> 

        <programlisting language="tex">
<![CDATA[ $(\exists y \forall x (y<x) \supset \neg (x \text{ prím}))$ ]]>
        </programlisting> 
        <para>
            Létezik olyan y minden x esetén, hogy ha y kisebb mint az x, akkor az x nem prímszám (tehát ugyanaz 
            mint az előző esteben, vagyis hogy véges sok prímszám van).
        </para>

        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/MatLog_LaTeX</link>
        </para>

        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/ZexiPy3ZxsA">https://youtu.be/ZexiPy3ZxsA</link>, <link xlink:href="https://youtu.be/AJSXOQFF_wk">https://youtu.be/AJSXOQFF_wk</link>
        </para>

        <para>
          First things first: Ragd be LAETX-be 
        </para>
    </section>                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
    <section>
        <title>Deklaráció</title>
            
        <para>
            Vezesd be egy programba (forduljon le) a következőket: 
        </para>
      <itemizedlist>
        <listitem>
          <para>egész</para>
          <para>
            <![CDATA[ int a]]>
          </para>
        </listitem>
        <listitem>
          <para>egészre mutató mutató</para>
          <para>
            <![CDATA[ std::add_pointer_t<std::add_pointer_t<decltype(3)>> a]]>
          </para>
        </listitem>
        <listitem>
          <para>egész referenciája</para>
          <para>
            <![CDATA[ std::add_lvalue_reference_t<decltype(4)> a]]>
          </para>
        </listitem>
        <listitem>
          <para>egészek tömbje</para>
          <para>
            <![CDATA[int a[5];]]>
          </para>
        </listitem>
        <listitem>
          <para>egészek tömbjének referenciája (nem az első elemé)</para>
          <para>
            <![CDATA[ int (&a)[64];]]>
          </para>
        </listitem>
        <listitem>
          <para>egészre mutató mutatók tömbje</para>
          <para>
            <![CDATA[int *a[64];]]>
          </para>
        </listitem>
        <listitem>
          <para>egészre mutató mutatót visszaadó függvény</para>
          <para>
            <![CDATA[int* f();]]>
          </para>
        </listitem>
        <listitem>
          <para>egészre mutató mutatót visszaadó függvényre mutató mutató</para>
          <para>
            <![CDATA[int* (*fn)();]]>
          </para>
        </listitem>
        <listitem>
          <para>egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvény</para>
          <para>
            <![CDATA[int (*fn(int))(int, int)]]>
          </para>
        </listitem>
        <listitem>
          <para>függvénymutató egy egészet visszaadó és két egészet kapó függvényre mutató mutatót visszaadó, egészet kapó függvényre</para>
          <para>
            <![CDATA[int (*(*fn)(int))(int, int)]]>
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Mit vezetnek be a programba a következő nevek?
      </para>

      <itemizedlist>
        <listitem>
          <programlisting><![CDATA[int a;]]></programlisting>
          <para>
            egy egész
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int *b = &a;]]></programlisting>
          <para>
            egész pointer
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int &r = a;]]></programlisting>
          <para>
            egész referencia
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int c[5];]]></programlisting>
          <para>
            egy egész tömb
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int (&tr)[5] = c;]]></programlisting>
          <para>
            egy egész tömb referencia
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int *d[5];]]></programlisting>
          <para>
            egész pointerek tömbje
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int *h ();]]></programlisting>
          <para>
            funkció ami egész pointert ad vissza
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int *(*l) ();]]></programlisting>
          <para>
            funkcióra mutató pointer ami egész pointert ad vissza
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int (*v (int c)) (int a, int b)]]></programlisting>
          <para>
            egy egészet kérő funkció ami egy pointert ad vissza egy funkcióra ami két egészet kér és egy egészet ad vissza
          </para>
        </listitem>
        <listitem>
          <programlisting><![CDATA[int (*(*z) (int)) (int, int);]]></programlisting>
          <para>
            egy egészet kérő funkcióra mutató pointer ami egy pointert ad vissza egy funkcióra ami két egészet kér és egy egészet ad vissza
          </para>
        </listitem>
      </itemizedlist>



      <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Az utolsó két deklarációs példa demonstrálására két olyan kódot
            írtunk, amelyek összahasonlítása azt mutatja meg, hogy miért 
            érdemes a <command>typedef</command> használata: <link xlink:href="Chomsky/fptr.c">
                <filename>Chomsky/fptr.c</filename>
            </link>,
            <link xlink:href="Chomsky/fptr2.c">
                <filename>Chomsky/fptr2.c</filename>.
            </link>  
            
        </para>
        <programlisting><![CDATA[#include <stdio.h>

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

int (*sumormul (int c)) (int a, int b)
{
    if (c)
        return mul;
    else
        return sum;

}

int
main ()
{

    int (*f) (int, int);

    f = sum;

    printf ("%d\n", f (2, 3));

    int (*(*g) (int)) (int, int);

    g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}]]></programlisting>            
        <programlisting><![CDATA[#include <stdio.h>

typedef int (*F) (int, int);
typedef int (*(*G) (int)) (int, int);

int
sum (int a, int b)
{
    return a + b;
}

int
mul (int a, int b)
{
    return a * b;
}

F sumormul (int c)
{
    if (c)
        return mul;
    else
        return sum;
}

int
main ()
{

    F f = sum;

    printf ("%d\n", f (2, 3));

    G g = sumormul;

    f = *g (42);

    printf ("%d\n", f (2, 3));

    return 0;
}
]]></programlisting>            
        <para>
            Nagyon nehéz a functio-pontier-functio.... es-atobbi deklarálása amikor iylen sokszor kell alkalmazni.
            Az a jó, hogy sokszor viszont nem kell alkalmazni ezt a módszert mert vagy túlbonyolítaná a dolgokat, vagy mert teljesen felesleges. Olvasni meg megérteni pláne a legnehezebb
            ezért ez a módszer kerülendő.
        </para>
    </section>                     

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
            Írj egy olyan <function>malloc</function> és <function>free</function>
            párost használó C programot, amely helyet foglal
            egy alsó háromszög mátrixnak a szabad tárban!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/1MRTuKwRsB0">https://youtu.be/1MRTuKwRsB0</link>,
            <link xlink:href="https://youtu.be/RKbX5-EWpzA">https://youtu.be/RKbX5-EWpzA</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="Caesar/tm.c">
                <filename>bhax/thematic_tutorials/bhax_textbook_IgyNeveldaProgramozod/Caesar/tm.c</filename>
            </link> 
        </para>
        <programlisting language="c"><![CDATA[#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int nr = 5;
    double **tm;

    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }

    for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }

    for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    tm[3][0] = 42.0;
    (*(tm + 3))[1] = 43.0;	// mi van, ha itt hiányzik a külső ()
    *(tm[3] + 2) = 44.0;
    *(*(tm + 3) + 3) = 45.0;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);

    return 0;
}]]></programlisting>
      <programlisting language="c">
        <![CDATA[#include <stdio.h>
#include <stdlib.h>

int
main ()
{
    int nr = 5;
    double **tm;
    
    printf("%p\n", &tm);

    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }
    printf("%p\n", tm); ]]>
      </programlisting>
      <para>
        A program első soraiban létrehozunk egy <varname>nr</varname> változót, melynek értéket is adunk: 5. Ez az ötös
        szám arra utal, hogy a program futtatását követően kiírt alsó háromszögmátrix (az eslő sorban eg elem lesz, a
        másodikban kettő, stb.) 5 soros lesz. A <command>double **tm</command> végrehajtódásakor deklaráljuk a
        <varname>tm</varname> nevű változót, a *-al jelezvén hogy ez egy pointer, egy mutató, és a program le is foglal neki monjuk 8 bájtnyi
        tárhelyet. Ezek után ki is íratjuk a tm memóriacímét. A következőkben szerepel a <function>malloc</function> függvény, amelyik (mint a <command>man 3 malloc</command>
        paracs lekérése után is kiderül), helyet foglal a memóriában és egy <type>void *</type> pointert ad vissza, ami bármire mutathat,
        majd mi megadunk meg egy típust, hogy arra mutasson amire mi akarjuk. A <function>malloc</function> paraméterül megkapja hogy mekkora
        területet kell lefoglajon, most egy sizeof paramétert kap, ami a <type>double *</type> tipus helyigényét adja vissza
        (tehát nr * sizeof (<type>double *</type>) = 5*8 = 40 bájtot kell lefoglaljon a tm számára). Az if-el at ellenőrizzük,
        hogy a <function>malloc</function> sikeresen lefoglalta-e a helyet a memóriában és hogy sikeresen vissza adta-e
        a <type>void *</type> mutatót. Ha ez nem sikerült, akkor egyenlő a NULL-al, vagyis nem mutat sehová és kilép a programból
        (ez akkor szokott bekövetkezni amikor nincs elegendő tárhelyünk és nem sikerül a memóriafoglalás).
        Tegyük fel, hogy nekünk ez most sikerült (ezért ki is íratjuk a tm <function>malloc</function> által visszaadott címét),
        ezért menjünk is tovább a program többi részére (a lefoglalt területet az ábrán a középső sor jelöli).
      </para>

      <programlisting language="c">
        <![CDATA[for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }
    printf("%p\n", tm[0]); ]]>
      </programlisting>
      <para>
        A következőkben egy for ciklussal úgymond végigmegyünk az 5 soron és mindengyik sorban úrja lesz egy
        memóriafoglalás. Nézzük pédának hogy mit fog csinálni abban az esetben amikor az <varname>i</varname>=3:
        mint mondottam a <function>malloc</function> egy  <type>void *</type> pointert ad vissza, de mi kikötjük hogy ez nekünk most <type>double *</type> legyen.
        A <function>malloc</function> a tm[2]-nek most (2+1 * 8) bájtot foglal, vagyis a harmadik sorban három 8
        bájtnyi helyet foglal le, a harmadik <type>double *</type> egy olyan sorra mutasson ahol három doublenek van lefoglalva hely
        (az ábrán ezt az utolsó sor urolsó három cellára jelöli). Ez az egész egy if feltételeként
        szerepel, melyben ismét ellenőrzi hogy sikeres volt-e a pointer létrehozása és a hely lefogalása, ha nem akkor egyenlő a NULL-lal
        és megáll a program. De tegyük fel újra, hogy sikerrel jártunk, ezért kiíratjuk a tm[0], az első sor memóriacímét,
        majd megyünk tovább.
      </para>

      <programlisting language="c">
        <![CDATA[for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = i * (i + 1) / 2 + j;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }]]>
      </programlisting>
      <para>
        Egy következő for ciklussal megszerkesztjük az alsó háromszögmátrixot (ehhez két for ciklus szükséges,
        mivel igy tudjuk meghatározni az elem sorát és oszlopát), azáltal, hogy az egyes, sor- és
        oszlopindexekkel jelölt elemek értéket kapnak (az <varname>i</varname>
        <varname>nr</varname>-ig, a
        <varname>j</varname> pedig <varname>i</varname>-ig megy, így biztosítva az alsó háromszögmátrix alakot).
        Lássuk, hogy hogy mülködik az értékadás, amikor az i=1 és j=0: ekkor a második sor első elemének adunk
        egy (1*2/2+0=) 1-es (double) értéket. Az értékadások végeztével, újabb for ciklusok segítségével kiíratjuk
        a kapott alsó háromszögmátrixot.
      </para>

      <programlisting language="c">
        <![CDATA[tm[3][0] = 42.0;
    (*(tm + 3))[1] = 43.0;	// mi van, ha itt hiányzik a külső ()
    *(tm[3] + 2) = 44.0;
    *(*(tm + 3) + 3) = 45.0;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }]]>
      </programlisting>
      <para>
        Ebben a részben az első négy sor különböző leírások arra, hogy a negyedik sorban lévő négy értéket
        hogy változtassuk meg, tehát példa arra, hogy hogyan lehet hivatkozni a különböző elemekre ahhoz
        hogy valamit tudjunk velük csinálni (ezesetben az értékmódosítás művelet végrehajtását). Az értékek
        megváltoztatása után újra kiíratjuk az alsó háromszögmátrixunkat.
      </para>
      <programlisting language="c">
        <![CDATA[
    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);

    return 0;
}]]>
      </programlisting>
      <para>
        A program utolsó részében a <function>free</function> függvény segítségével felszabadítjuk az egyes sorokban
        illetve az egesz tm által foglalt memóriát.
      </para>
      <para>
        Fordítás: <command>gcc tm.c -o tm</command>
      </para>
      <para>
        Futtatás: <command>./tm</command>
      </para>

      <figure>
            <title>A <type>double **</type> háromszögmátrix a memóriában</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/doublecscs.png" scale="50"/>
                </imageobject>
                <textobject>
                    <phrase>A <type>double **</type> háromszögmátrix a memóriában</phrase>
                </textobject>
            </mediaobject>
        </figure>                             
        <para>
            
        </para>            
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
      <programlisting language="c">
        <![CDATA[﻿#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define MAX_KULCS 100
#define BUFFER_MERET 256


int
main (int argc, char **argv)
{

  char kulcs[MAX_KULCS];
  char buffer[BUFFER_MERET];

  int kulcs_index = 0;
  int olvasott_bajtok = 0;

  int kulcs_meret = strlen (argv[1]);
  strncpy (kulcs, argv[1], MAX_KULCS);

  while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
    {

      for (int i = 0; i < olvasott_bajtok; ++i)
	{

	  buffer[i] = buffer[i] ^ kulcs[kulcs_index];
	  kulcs_index = (kulcs_index + 1) % kulcs_meret;

	}

      write (1, buffer, olvasott_bajtok);

    }
}]]>
      </programlisting>
      <para>
        Egy <command>tiszta.szoveg</command> nevű féjl létrehozása, egy szöveg beletétele.
      </para>
      <para>
        Fordítás: <command>gcc e.c -o e -std=c99</command>
      </para>
      <para>
        Futtatás: <command>./e kulcs &lt;tiszta.szoveg &gt;titkos.szoveg</command> (a kulcs bármi lehet)
      </para>
      <para>
        Dekódolás: <command>./e kulcs &lt;titkos.szoveg</command> (a kulcs meg kell egyezzen a fent használt kulccsal)
      </para>
      <para>
        Az exor titkosító, mint ahogy a neve is mondja, exor müvelet segítségével szöveget titkosít a számunkra.
        A bevitt, titkosítandó szöveg emberi fogyasztásra alkalmas, de a titkosított viszont már annál kevésbé.
        A dekósolásnál lévő parncs segítségével képesek vagyunk a titkos szövegből visszaadni az eredeti szöveget.
        A program elején deklarálunk egy kulcsot, egy buffert (ami az olvasott bájtok egyes bájtjait veszi fel),
        majd bekérjük az olvasott bájtokat (a mi esetünkben a tiszta.szoveg nevű fájlból).
        A program egyessével végigmegy a beolvasott bájtokon, majd azokat össze xorozza az adott kulcs indexel ami
        a kulcsban következik, majd a kulcson belül is továbblép a következő karakterre (ha a kulcs 4 karakter akkor
        sorban mindig azon a 4 karakteren megy végig). Ezért játszik fontos szerepet a kulcs, mivel anélkül nem
        tudjuk feltörni a titkosított szöveget.
      </para>

    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/ch01.html#exor_titkosito</link>               
        </para>
      <para>
        A következő java program egy titkosító és egyben egy törő program is, mivel ha újra végrehajtjuk a titkosítást
        akkor visszakapjuk az eredeti szöveget. Ezt az müveletet az exortitkosito osztályban végezzük el.
      </para>
      <programlisting language="c">
        <![CDATA[public class exortitkosito {
    
    public exortitkosito(String kulcsSzöveg,
            java.io.InputStream bejövőCsatorna,
            java.io.OutputStream kimenőCsatorna)
            throws java.io.IOException {
        
        byte [] kulcs = kulcsSzöveg.getBytes();
        byte [] buffer = new byte[256];
        int kulcsIndex = 0;
        int olvasottBájtok = 0;

        while((olvasottBájtok =
                bejövőCsatorna.read(buffer)) != -1) {
            
            for(int i=0; i<olvasottBájtok; ++i) {
                
                buffer[i] = (byte)(buffer[i] ^ kulcs[kulcsIndex]);
                kulcsIndex = (kulcsIndex+1) % kulcs.length;
                
            }
            
            kimenőCsatorna.write(buffer, 0, olvasottBájtok);
            
        }
        
    }
    
    public static void main(String[] args) {
        
        try {
            
            new exortitkosito(args[0], System.in, System.out);
            
        } catch(java.io.IOException e) {
            
            e.printStackTrace();
            
        }
        
    }
    
}]]>
      </programlisting>
      <para>
        Mint mindegyik titkosító/törő programban van egy ciklus melyik apránként olvassa a bemenetet, ebben az esetben
        egy while ciklus, mely tömbönként olvas be. A titkosítás folyamata teljesen az mint az előző C exor titkosító
        programban. A <varname>kulcsIndex</varname>-et ráállítjuk a kulcs adott karakterére ami következik, majd ezen és
        a buffer által beolvasott karakteren elvégezzük a kizáró vagy műveletet. Az eredmény a buffer tömbbe kerül, a program
        végén ezt íratjuk majd ki.
      </para>
      <para>
        A program futtatása (titkosítandó szöveg bekérése, titkosítása és visszaváltoztatása):
      </para>
      <para>
        <command>javac exortitkosito.java</command> (létrejön az exortitkosito.class fájl)
      </para>
      <para>
        <command>java exortitkosito alma &gt;  titkositott.txt</command> (a titkosítandó szöveg bevitele)
      </para>
      <para>
        <command>more titkositott.txt</command> (kiíratódik a titkosított szöveg)
      </para>
      <para>
        <command>java exortitkosito alma &lt;  titkositott.txt</command> (dekódoljuk a titkosított szöveget, visszakapva az eredetit)
      </para>

    </section>        
    <section xml:id="bhax-textbook-feladatok-caesar.EXOR-toro">
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
      <programlisting language="c">
        <![CDATA[#define MAX_TITKOS 4096
#define OLVASAS_BUFFER 256
#define KULCS_MERET 8
#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <string.h>

double
atlagos_szohossz (const char *titkos, int titkos_meret)
{
  int sz = 0;
  for (int i = 0; i < titkos_meret; ++i)
    if (titkos[i] == ' ')
      ++sz;

  return (double) titkos_meret / sz;
}

int
tiszta_lehet (const char *titkos, int titkos_meret)
{
  // a tiszta szoveg valszeg tartalmazza a gyakori magyar szavakat
  // illetve az átlagos szóhossz vizsgálatával csökkentjük a
  // potenciális töréseket

  double szohossz = atlagos_szohossz (titkos, titkos_meret);

  return szohossz > 6.0 && szohossz < 9.0
    && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
    && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

}]]>
      </programlisting>
      <para>
        A program elején lesz három nagyon fontos és beszédes definíciónk: A titkos szöveg maximum mérete, a beolvasott
        buffer mérete és a kulcs mérete, ami, az előző programmal szemben, itt már nem lehet akármi, hanem ezt a program
        végén fogjuk ezt iterálni, most annyit tudunk hogy 8 hosszúságú. A <function>atlag_szohossz</function> függvénynek
        is beszédes neve van, ezt a függvényt a következő függvényben már használjuk is ami nemmás mint a <function>tiszta_lehet</function>.
        Ez a függvény úgymond megtippeli, hogy a szöveg amit kapott az megfelel-e a magyar nyelv néhány iratlan szabályának,
        mint például az hogy tartalmazza-e a leggyakoribb magyar szavakat (hogy, nem, az, ha), mivel ritka az az értelmes
        magyar nyelven íródott szöveg amikben ezek egyike legalább nem fordul elő.
      </para>

      <programlisting language="c">
        <![CDATA[void
exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
{

  int kulcs_index = 0;

  for (int i = 0; i < titkos_meret; ++i)
    {

      titkos[i] = titkos[i] ^ kulcs[kulcs_index];
      kulcs_index = (kulcs_index + 1) % kulcs_meret;

    }

}]]>
      </programlisting>
      <para>
        A követező függvény az ami a tiszta szövegből titkosat csinál az exor művelet segítségével, ugyanazzal a
        módszerrel mint az Exor titkosító programban. A program egyessével végigmegy a beolvasott bájtokon, majd
        azokat össze xorozza az adott kulcs indexel ami a kulcsban következik, majd a kulcson belül is továbblép
        a következő karakterre.
      </para>

      <programlisting language="c">
        <![CDATA[int
exor_tores (const char kulcs[], int kulcs_meret, char titkos[],
	    int titkos_meret)
{

  exor (kulcs, kulcs_meret, titkos, titkos_meret);

  return tiszta_lehet (titkos, titkos_meret);

}]]>
      </programlisting>
      <para>
        Nagy meglepődésünkre a törő függvény nem rendelkezik külön erre a célra kifejlesztett algoritmussal, hanem
        felhasználja az előbb bemutatott <function>exor</function> függvényt, mivel ha valamit exorozunk egy adott
        kulccsal, majd ugyanazzal a kulccsal újra megcsináljuk az exor műveletet akkor visszakapjuk az eredeti szöveget.
        Az exor eme tulajdonságát kihasználva az <function>exor_toro</function> elvégzi a titkos szöveg visszaváltoztatását
      </para>

      <programlisting language="c">
        <![CDATA[int
main (void)
{

  char kulcs[KULCS_MERET];
  char titkos[MAX_TITKOS];
  char *p = titkos;
  int olvasott_bajtok;

  // titkos fajt berantasa
  while ((olvasott_bajtok =
	  read (0, (void *) p,
		(p - titkos + OLVASAS_BUFFER <
		 MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
    p += olvasott_bajtok;

  // maradek hely nullazasa a titkos bufferben  
  for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
    titkos[p - titkos + i] = '\0';

  // osszes kulcs eloallitasa
  for (int ii = '0'; ii <= '9'; ++ii)
    for (int ji = '0'; ji <= '9'; ++ji)
      for (int ki = '0'; ki <= '9'; ++ki)
	for (int li = '0'; li <= '9'; ++li)
	  for (int mi = '0'; mi <= '9'; ++mi)
	    for (int ni = '0'; ni <= '9'; ++ni)
	      for (int oi = '0'; oi <= '9'; ++oi)
		for (int pi = '0'; pi <= '9'; ++pi)
		  {
		    kulcs[0] = ii;
		    kulcs[1] = ji;
		    kulcs[2] = ki;
		    kulcs[3] = li;
		    kulcs[4] = mi;
		    kulcs[5] = ni;
		    kulcs[6] = oi;
		    kulcs[7] = pi;

		    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
		      printf
			("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
			 ii, ji, ki, li, mi, ni, oi, pi, titkos);

		    // ujra EXOR-ozunk, igy nem kell egy masodik buffer  
		    exor (kulcs, KULCS_MERET, titkos, p - titkos);
		  }

  return 0;
}]]>
      </programlisting>
      <para>
        Következik a main, a főprogram ahol az előbbieket felhasználjuk. Beolvassuk a titkos szöveget, és itt látszik
        egy nagy különbség az előző C exor titkosító programmal, ez nem foglal le külön területet a tiszta illetve a titkos
        szövegnek, tehát a kódolt és a dekódolt szövegnek. A titkos szöveg bekérése után, megnézi hogy a kisebb e a mérete
        mint amennyit az elején lefoglalt neki a MAX_TITKOS-ba, ha igen akkor a maradék helyet kinullázza. Ezután előállítja
        a kulcsokat majd jöhet az exorozás, tehát a törés és a titkosítás müvelete.
      </para>

      <para>
        Fordítás: <command>gcc t.c -o t</command>
      </para>
      <para>
        Futtatás: <command>./t</command>
      </para>

    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
        <para>
          A neurális hálók irányított (bemeneti és kimeneti) kapcsolatokkal összekötött egységekből állnak. Az a(0-j)
          az inputról (más idegsejtekből) bejövő axonok, kapcsolatok (az "a"-k). Ezekből az "a"-kból rendre csinál egy eltolási súlyt,
          a W-t, ami meghatározza a kapcsolat erősségét és előjelét, majd ezt a megfelelő "a"-val összeszummázza, tehát
          i a bemenetek egy súlyozott összege lesz. A kapott összegre alkalmazunk egy aktivációs függvényt (g), ezáltal
          megkapva a kimeneti kapcsolatot.
        </para>
      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Caesar/neutoae.r">../Caesar/neutoae.r</link>
      </para>


    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/XpBnR31BRJY">https://youtu.be/XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>               
        </para>
      <para>
        Ez a program sokban kötődik az előző programhoz, mivel ebben is egyfajta tanítási módszert mutatunk be.
        A perceptronok, másnéven egyrétegű előrecsatolt neurális hálók, olyan hálók amelyekben az összes bemenet
        közvetlenül a kimenetekre kapcsolódik (minden súly csak egy kimenetre van hatással). A perceptronok az alap
        logikai műveleteken túl képesek a bonyolultabbakat is bemutatni röviden. A hiba-visszaterjesztést többrétegű perceptron
        (MLP) esetén tudjuk csak alkalmazni. A többrétegű perceptron rétegekbe szervezett neuronokból áll. A rétegek mennyisége
        többnyire változó, minden esetben van egy bemeneti-, egy kimeneti- és a kettő között egy vagy több rejtett réteg
        A következő programok együttese olyan algoritmus, amelyik megtanítja a gépnek a bináris osztályozást.
      </para>
      <para>
        A forráskód megtalálható a következő linken: <link xlink:href="Caesar/mandelpng.cpp">../Caesar/mandelpng.cpp</link>
      </para>
      <para>
        Szükségünk van még a következő programra, amelyik megtalálható a következő linken: <link xlink:href="Caesar/perceptron.hpp">../Caesar/perceptron.hpp</link>
      </para>

      <para>
        A forráskód megtalálható a következő linken: <link xlink:href="Caesar/main.cpp">../Caesar/main.cpp</link>
      </para>
      <programlisting language="c">
        <![CDATA[#include <iostream>
#include "perceptron.hpp"
#include "png++/png.hpp"

int main (int argc, char **argv)
{
    png::image <png::rgb_pixel> png_image (argv[1]);

    int size = png_image.get_width() * png_image.get_height();
    
    Perceptron* p = new Perceptron (3, size, 256, 1);
    
    double* image = new double[size];
    
    for (int i = 0; i<png_image.get_width(); ++i)
        for (int j = 0; j<png_image.get_height(); ++j)
            image[i*png_image.get_width() + j] = png_image[i][j].red;
    
    double value = (*p) (image);
    
    std::cout << value << std::endl;
    
    delete p;
    delete [] image;   
}]]>
      </programlisting>
      <para>
        A fentebb említett perceptron.cpp programot a mainben meg is hívjuk header fájlként, átláthatóbbá téve a főprogramot. A fő számítások viszont a perceptron.hpp-ben
        vannak, a mainben az ott deklarált Perceptron osztályt hívjuk segítségül meg az eredmény kiszámolásának céljából.
        A mainben a png.hpp header fájl segítségével létrehozunk egy új png kiterjesztésű képet, úgyanolyan szélességgel és magasséggal
        mint a mandelbrotos kép volt. A két egymásbaágyazódó for ciklus segítségével végigmegyünk a kép minden pixelén és az előzőekben
        lementett mandel_perceptron.png pixeleinek piros (red) komponenseit rámásoljuk a most létrehozott kép pixeleire. A program végén
        pedig kiíratjuk ezt a percceptron értéket a <varname>value</varname> változó segítségével.
      </para>

      <para>
        Fordítás: <command>g++ perceptron.hpp main.cpp -o main -lpng -std=c++11</command>
      </para>
      <para>
        Futtatás: <command>./main mandel_perceptron.png </command>
      </para>
      <para>
        A kiadott eredmény: <command>0.731044</command>
      </para>

    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot! Teszt</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title>A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngt.c++">
                <filename>bhax/attention_raising/CUDA/mandelpngt.c++</filename>
            </link> nevű állománya.            
        </para>
      <para>
        Az ebben a fejezetben szereplő programok, mind szervesen kötődnek egymáshoz. Ha sikerül egy képet megcsinálni
        akkor az összes programot át tudjuk rá ültetni, tehát egy másik programváltozattal tudunk benne majd nagyítani,
        vagy úgy is át tudjuk majd írni, hogy a GPU-t használja, ezáltal nagyon meggyorsítva a számítási folyamatokat.
      </para>
      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Mandelbrot/mandelpngt.cpp">../Mandelbrot/mandelpngt.cpp</link>
      </para>
      <programlisting language="c++">
        <![CDATA[// mandelpngt.c++
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
//  Mandelbrot png
//  Programozó Páternoszter/PARP
//   https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux
//
//  https://youtu.be/gvaqijHlRUs
//
#include <iostream>
#include "png++/png.hpp"
#include <sys/times.h>

#define MERET 600
#define ITER_HAT 32000]]>
      </programlisting>
      <para>
        A program elején, mint mindig, megadjuk a header fájlokat. Ez esetben ami ismeretlen lehet az a png++/png.hpp
        és a sys/times.h fejlécek. Az elsőre azért van szükségünk, hogy létre tudjuk hozni a képet, hogy viziálisan
        is láthassuk a Mandelbrot halmaz eredményét, ami kép. A második header fájl pedig az idővel kapcsolatos számításokat,
        az idővel összefüggő függvények meghívását biztosítja számunkra. Idlletve efiníciő megadaások is szerepelnek,
        melyek majd könnyítik a dolgunkat a program írása alatt.
      </para>

      <programlisting language="c++">
        <![CDATA[void
mandel (int kepadat[MERET][MERET]) {

    // Mérünk időt (PP 64)
    clock_t delta = clock ();
    // Mérünk időt (PP 66)
    struct tms tmsbuf1, tmsbuf2;
    times (&tmsbuf1);

    // számítás adatai
    float a = -2.0, b = .7, c = -1.35, d = 1.35;
    int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

    // a számítás
    float dx = (b - a) / szelesseg;
    float dy = (d - c) / magassag;
    float reC, imC, reZ, imZ, ujreZ, ujimZ;
    // Hány iterációt csináltunk?
    int iteracio = 0;
    // Végigzongorázzuk a szélesség x magasság rácsot:
    for (int j = 0; j < magassag; ++j)
        {
        //sor = j;
        for (int k = 0; k < szelesseg; ++k)
            {
            // c = (reC, imC) a rács csomópontjainak
            // megfelelő komplex szám
            reC = a + k * dx;
            imC = d - j * dy;
            // z_0 = 0 = (reZ, imZ)
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            // z_{n+1} = z_n * z_n + c iterációk
            // számítása, amíg |z_n| < 2 vagy még
            // nem értük el a 255 iterációt, ha
            // viszont elértük, akkor úgy vesszük,
            // hogy a kiinduláci c komplex számra
            // az iteráció konvergens, azaz a c a
            // Mandelbrot halmaz eleme
            while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
                {
                // z_{n+1} = z_n * z_n + c
                ujreZ = reZ * reZ - imZ * imZ + reC;
                ujimZ = 2 * reZ * imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                ++iteracio;
                }

            kepadat[j][k] = iteracio;
            }   
        }

        times (&tmsbuf2);
        std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
        + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

        delta = clock () - delta;
        std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

        }]]>
      </programlisting>
      <para>
        A <function>mandel</function> függvény az ami majd kiszámolja nekünk a Mandelbrot halmazt. Egy időszámítás jön,
        ami segítségével majd a program lefutás után kiírja azt az időt amit igénybe vett a számolás (az én
        gépen és egy i3-3227U-s processzor esetén ez körülbelül egy 15 másodpercbe telt). Ezek és a
        változódeklarálások után jöhetnek a nagyobb számítások. Létrehozunk egy dx szélességű és dy magasságú
        rácsot a két egymásbaágyazódó for ciklus segítségével, majd megvizsgáljuk, hogy a <varname>c</varname> komplex szám (mely megkapja a <varname>reC</varname>
        és a <varname>imC</varname> értékek által meghatározott pontot, pixelt) benne van-e a Mandelbrot halmazban,
        ha igen akkor azt a pontot beszinezi.
      </para>

      <programlisting language="c++">
        <![CDATA[int
main (int argc, char *argv[])
{

    if (argc != 2)
    {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }

    int kepadat[MERET][MERET];

    mandel(kepadat);

    png::image < png::rgb_pixel > kep (MERET, MERET);

    for (int j = 0; j < MERET; ++j)
    {
        //sor = j;
        for (int k = 0; k < MERET; ++k)
        {
            kep.set_pixel (k, j,
            png::rgb_pixel (255 -
            (255 * kepadat[j][k]) / ITER_HAT,
            255 -
            (255 * kepadat[j][k]) / ITER_HAT,
            255 -
            (255 * kepadat[j][k]) / ITER_HAT));
        }
    }

    kep.write (argv[1]);
    std::cout << argv[1] << " mentve" << std::endl;
}]]>
      </programlisting>
      <para>
        A főprogram elején megvizsgáljuk, hogy a felhasználó jól hsználta-e a futtatási parancsot, tehát hogyha a parancs nem két
        argumentumból áll, akkor kiírunk egy hibaüzenetet a kimenetre. A <varname>kepadat</varname> változóba bekérjük a méreteket,
        tehát a kép szélességét és a magasságát majd ezeket átadjuk a <function>mandel</function> függvénynek, ami kiszámolja nekünk
        a mandelbrot halmazt, és ez alapján megalkotjuk a png kiterjesztésű képet. Miutána  program befejezte a számításokat és
        sikeresen megcsinálta a képet, kiírja a kimenetre a "mentve" üzenetet a felhasználó számára, tudatva a sikert.
      </para>

      <para>
        Fordítás: <command>g++ mandelpngt.cpp -lpng -O3 -omandelpngt</command>
      </para>
      <para>
        Futtatás: <command>./mandelpngt mt.png</command>
      </para>
      <para>
        Kép megnyitása terminálból: <command>eog mt.png</command>
      </para>
      <figure>
        <title>A kiadott kép</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Mandelbrot/mt.png" scale="50"/>
          </imageobject>
          <textobject>
            <phrase>A kiadott kép</phrase>
          </textobject>
        </mediaobject>
      </figure>



    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>        
A <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link> pontban vázolt
ismert algoritmust valósítja meg a repó <link xlink:href="../../../bhax/attention_raising/Mandelbrot/3.1.2.cpp">
                <filename>bhax/attention_raising/Mandelbrot/3.1.2.cpp</filename>
            </link> nevű állománya.
        </para>
      <para>
        Felvetődik egy kérdés: melyikaz a szám amelyiket önmagával megszorozva 9-et kapunk (természetesen ez a 3).
        Ebből kiindulva a következő kérdés pedig az, hogy melyik az a szám amit ha megszorozunk önmagával -9-et kapunk?
        Ez pedig már nem lehetséges a valós számhalmazon, így jönnek képbe a komplex számok, melyek úgymond a valós
        számhalmaz továbbővítése. A komplex számok alapja az "i" szám, melynek értéke a sqrt(-1), ennek a segítségével
        el lehet végezni a negatív számból való négyzetgyökvonást. Így már meg tudjuk válaszolni az előbb feltett kérdést,
        az "i" szám segítségével már ki tudjuk hozni a -9-et (tehát 3i*3i).
      </para>
      <para>
        Ez a program és az előző közötti legnagyobb kölönbség az hogy a <varname>c</varname> amit vizsgálunk, hogy benne van-e
        a Mandelbrot halmazban, az előző programban egy változó, ebben pedig egy állandó. Így itt a c a rács minden
        vizsgálandó pontját befutja.
      </para>
      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Mandelbrot/mandelbrotcomplex.cpp">../Mandelbrot/mandelbrotcomplex.cpp</link>
      </para>
      <programlisting language="c++">
        <![CDATA[// Verzio: 3.1.2.cpp
// Forditas:
// g++ 3.1.2.cpp -lpng -O3 -o 3.1.2
// Futtatas:
// ./3.1.2 mandel.png 1920 1080 2040 -0.01947381057309366392260585598705802112818 -0.0194738105725413418456426484226540196687 0.7985057569338268601555341774655971676111 0.798505756934379196110285192844457924366
// ./3.1.2 mandel.png 1920 1080 1020 0.4127655418209589255340574709407519549131 0.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874
// Nyomtatas:
// a2ps 3.1.2.cpp -o 3.1.2.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// ps2pdf 3.1.2.cpp.pdf 3.1.2.cpp.pdf.pdf
//
//
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.


#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

  int szelesseg = 1920;
  int magassag = 1080;
  int iteraciosHatar = 255;
  double a = -1.9;
  double b = 0.7;
  double c = -1.3;
  double d = 1.3;

  if ( argc == 9 )
    {
      szelesseg = atoi ( argv[2] );
      magassag =  atoi ( argv[3] );
      iteraciosHatar =  atoi ( argv[4] );
      a = atof ( argv[5] );
      b = atof ( argv[6] );
      c = atof ( argv[7] );
      d = atof ( argv[8] );
    }
  else
    {        
      std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d" << std::endl;
      return -1;
    }]]>
      </programlisting>
      <para>
        A program elején a header fájlok deklarálása után (iostream, a cin, cout miatt főleg; png++/png.hpp,
        a kép létrehozása miatt; complex, a komplex iterációk és ahogy a címben is említve van a komplex osztályos megoldás miatt) jönnek a változók deklarálása, ezek a változók
        (<varname>szelesseg</varname>, <varname>magassag</varname>, <varname>iteraciosHatar</varname>, <varname>a</varname>,
        <varname>b</varname>, <varname>c</varname> és <varname>d</varname>) a futtaási parancsban is fontos szerepet
        játszanak hiszen az első két argumentum után (ami a ./futtató fájl neve illetve egy png féjlnév, ami a mentett kép
        neve lesz) ahogy deklarálva vannak, úgynilyen sorrenbe vannak megadva szóközzel elválasztva egymástól. Miután a változók
        deklarálva lettek, megvizsgéljuk hogy a felhasználó jól futtat-e a programot, tehét hogyha a parans 9 argumentumból áll
        akkor megadjuk a programban, hogy az egyes változók hányadik értéket kapják meg a parancsból, tehát hogy a program tudja
        hogy az egyes értékek mit jelentenek számára. Ha vizsont a parancs nem 9 argumentumból áll, akkor kiíratunk az outputra
        egy üzenetet a felhasználónak, hogy tudja a helyes futtatási használatot, <command>return -1</command>-el pedig az
        operációs rendszernek is jelezzük a hibát.
      </para>

      <programlisting language="c++">
        <![CDATA[  png::image < png::rgb_pixel > kep ( szelesseg, magassag );

  double dx = ( b - a ) / szelesseg;
  double dy = ( d - c ) / magassag;
  double reC, imC, reZ, imZ;
  int iteracio = 0;

  std::cout << "Szamitas\n";

  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {
          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }

          kep.set_pixel ( k, j,
                          png::rgb_pixel ( iteracio%255, (iteracio*iteracio)%255, 0 ) );
        }

      int szazalek = ( double ) j / ( double ) magassag * 100.0;
      std::cout << "\r" << szazalek << "%" << std::flush;
    }

  kep.write ( argv[1] );
  std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
      </programlisting>
      <para>
        A számítások részben deklaráljuk a <varname>reC</varname>, <varname>imC</varname>, <varname>reZ</varname>
        és <varname>imZ</varname> (valós és imaginárius részű) változókat, melyekből már látszik is hogy a feladatban
        sokszerepet fognak játszani a komplex számok. A c=(reC, imC) a haló rácspontjainak megfelelő aktualis pont
        Úgyanúgy mint az előző programban a két for ciklus segítségével megcsináljuk a rácsot, elindulunk az
        origóban majd egy <varname>c</varname> pontra ugrunk a c<superscript>2</superscript>+c majd ez az egesz a
        négyzeten +c és így tovább. Ha sikeres volt minden művelet, akkor kiíratunk a standard kimenetre egy "mentve"
        üzenetet, melyből a felhasználó tudja is hogy a kép sikeresen el lett készítve, lehet megtekinteni.
      </para>
      <para>
        Fordítás: <command>g++ mandelbrotcomplex.cpp -lpng -O3 -o mandelbrotcomplex</command>
      </para>
      <para>
        Futtatás: <command>
          ./mandelbrotcomplex mandelcomplex.png 1920 1080 1020
          0.4127655418209589255340574709407519549131
          0.4127655418245818053080142817634623497725
          0.2135387051768746491386963270997512154281
          0.2135387051804975289126531379224616102874
        </command>
      </para>
      <para>
        Kép megnyitása terminálból: <command>eog mandelcomplex.png</command>
      </para>
      <figure>
        <title>A program áltak megcsinált kép</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Mandelbrot/mandelcomplex.png" scale="20"/>
          </imageobject>
          <textobject>
            <phrase>A program áltak megcsinált kép</phrase>
          </textobject>
        </mediaobject>
      </figure>

    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
      <para>
        A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk:
        <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
        Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a
        korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló
        forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
      </para>
      <para>
        A cikkben arról olvashatunk, hogy Pickover amikor felfedezte a biomorfokat, teljesen meg volt győződve
        arról hogy felfedezte a természet törvényeit, tehát hogy hogyan néznek ki és alakulnak ki az élő orgazmusok.
        A cikkben látjuk azt is, hogy a különböző képeket különböző függvények segítségével hozunk létre, hasonlóan a Mandelbrot
        halmazhoz, elindul a rácson és azon végzi el a képhez tartozó függvényt. A program a komplex számsíkon dolgozik,
        tehát van "i" számunk, és a c egy állandó .Próbáljuk ki és nézzük meg hogy hogy is mülködik a program.
      </para>
      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Mandelbrot/biomorfok.cpp">../Mandelbrot/biomorfok.cpp</link>
      </para>
      <programlisting language="c++">
        <![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }]]>
      </programlisting>
      <para>
        Header fájlként megadjuk a képkészítéshez a png++/png.hpp fejlécet, majd ami új az pedig a complex header fájl
        ami természetesen a komplex számokkal való számolás miatt kell. Ezek után már kezdjük is a főprogramot, melyben
        legelőször deklaráljuk a változókat, majd meghatározzuk a magasságot, szálességet és a rácsban való mozgáshoz
        szükségez koordnátákat. Ez a kép kirajzoltatásához a <varname>c</varname> állandó értékében most nincs "i", ezért
        a <varname>c</varname>-nek a valós részéhez (reC) adunk meg 0-tól különböző értéket, az imaginárius, képzett
        részéhez (imC) pedig 0-t.
      </para>

      <programlisting language="c++">
        <![CDATA[png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
      </programlisting>
      <para>
        A következő programrészben, az első pixelre állunk, majd elkezdjük a számításokat. A két egymásbaágyzó for
        ciklussal rácsot teszünk a komplex számsíkra (ahol a <varname>j</varname>-vel a soron, a <varname>k</varname>-al
        pedig az oszlopon megyünk végig). Az előző complex osztállyal megvalósított Mandelbrot halmazzal szemben, itt a
        <varname>cc</varname> nem változik, hanem minden vizsgált z rácspontra ugyanaz, állandó lesz (a program eme változata
        a Júlia halmaz része). A mi programunkban a függvény a kövztkezőképpen néz ki: z_n<superscript>3</superscript>+c.
        A függűvény változtatásával a készített kép is fog változni.
      </para>

      <para>
        Fordítás: <command>g++ biomorfok.cpp -lpng -O3 -o biomorfok</command>
      </para>
      <para>
        Futtatás: <command>./biomorfok biomorf.png 800 800 10 -2 2 -2 2 .285 0 10</command>
      </para>
      <para>
        Kép megnyitása terminálból: <command>eog biomorf.png</command>
      </para>
      <figure>
        <title>Biomorf kép</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Mandelbrot/biomorf.png" scale="40"/>
          </imageobject>
          <textobject>
            <phrase>Biomorf kép</phrase>
          </textobject>
        </mediaobject>
      </figure>

    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>

      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Mandelbrot/mandelpngc_60x60_100.cu">../Mandelbrot/mandelpngc_60x60_100.cu</link>
      </para>
      <programlisting>
        <![CDATA[// mandelpngc_60x60_100.cu
// Copyright (C) 2019
// Norbert Bátfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
//  Mandelbrot png
//  Programozó Páternoszter/PARP
//   https://www.tankonyvtar.hu/hu/tartalom/tamop412A/2011-0063_01_parhuzamos_prog_linux
//
//  https://youtu.be/gvaqijHlRUs
//

#include <png++/image.hpp>
#include <png++/rgb_pixel.hpp>

#include <sys/times.h>
#include <iostream>


#define MERET 600
#define ITER_HAT 32000

__device__ int
mandel (int k, int j)
{
  // számítás adatai
  float a = -2.0, b = .7, c = -1.35, d = 1.35;
  int szelesseg = MERET, magassag = MERET, iteraciosHatar = ITER_HAT;

  // a számítás
  float dx = (b - a) / szelesseg;
  float dy = (d - c) / magassag;
  float reC, imC, reZ, imZ, ujreZ, ujimZ;
  // Hány iterációt csináltunk?
  int iteracio = 0;

  // c = (reC, imC) a rács csomópontjainak
  // megfelelő komplex szám
  reC = a + k * dx;
  imC = d - j * dy;
  // z_0 = 0 = (reZ, imZ)
  reZ = 0.0;
  imZ = 0.0;
  iteracio = 0;

  while (reZ * reZ + imZ * imZ < 4 && iteracio < iteraciosHatar)
    {
      // z_{n+1} = z_n * z_n + c
      ujreZ = reZ * reZ - imZ * imZ + reC;
      ujimZ = 2 * reZ * imZ + imC;
      reZ = ujreZ;
      imZ = ujimZ;

      ++iteracio;

    }
  return iteracio;
}

__global__ void
mandelkernel (int *kepadat)
{

  int tj = threadIdx.x;
  int tk = threadIdx.y;

  int j = blockIdx.x * 10 + tj;
  int k = blockIdx.y * 10 + tk;

  kepadat[j + k * MERET] = mandel (j, k);
}

void
cudamandel (int kepadat[MERET][MERET])
{
  int *device_kepadat;
  cudaMalloc ((void **) &device_kepadat, MERET * MERET * sizeof (int));

  dim3 grid (MERET / 10, MERET / 10);
  dim3 tgrid (10, 10);
  mandelkernel <<< grid, tgrid >>> (device_kepadat);  
  
  cudaMemcpy (kepadat, device_kepadat,
	      MERET * MERET * sizeof (int), cudaMemcpyDeviceToHost);
  cudaFree (device_kepadat);
}

int
main (int argc, char *argv[])
{
  // Mérünk időt (PP 64)
  clock_t delta = clock ();
  // Mérünk időt (PP 66)
  struct tms tmsbuf1, tmsbuf2;
  times (&tmsbuf1);

  if (argc != 2)
    {
      std::cout << "Hasznalat: ./mandelpngc fajlnev";
      return -1;
    }

  int kepadat[MERET][MERET];
  cudamandel (kepadat);
  png::image < png::rgb_pixel > kep (MERET, MERET);

  for (int j = 0; j < MERET; ++j)
    {
      //sor = j;
      for (int k = 0; k < MERET; ++k)
	{
	  kep.set_pixel (k, j,
			 png::rgb_pixel (255 -
					 (255 * kepadat[j][k]) / ITER_HAT,
					 255 -
					 (255 * kepadat[j][k]) / ITER_HAT,
					 255 -
					 (255 * kepadat[j][k]) / ITER_HAT));
	}
    }
  kep.write (argv[1]);

  std::cout << argv[1] << " mentve" << std::endl;

  times (&tmsbuf2);
  std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime
    + tmsbuf2.tms_stime - tmsbuf1.tms_stime << std::endl;

  delta = clock () - delta;
  std::cout << (float) delta / CLOCKS_PER_SEC << " sec" << std::endl;

}]]>
      </programlisting>
      <para>
        Ugynúgy mint a legelső Mandelbrotos feladat, a mandelbrot halmazt számolja ki, hasonló műveletekkel,
        viszont van egy nagy különbség a kettő között: míg az első a CPU-t használja a számítások közben, addig ez a
        program a GPU-t használja. A program futtatása után a számok melyek az időt mutatják magukért beszélnek.
        Míg a CPU-t használó program 15 másodpercet vett igénybe, addig CUDA-s program mintegy 0.15 másodperc
        alatt kiszámolja nekünk ugyanazt az eredményt. A két program leírásban nagyon hasonlít az előző feladathoz,
        mint mondtam itt a számítási idők mások, ezt az időt a program során számoljuk és iratjuk ki, hogy legyen ű
        vizsonyítási alapunk.
      </para>

    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.        </para>
        <para>
             Megoldás forrása: az ötödik előadás <link xlink:href="https://arato.inf.unideb.hu/batfai.norbert/UDPROG-BHAX/Prog1_5.pdf">26-33 fólia</link>, 
            illetve <link xlink:href="https://sourceforge.net/p/udprog/code/ci/master/tree/source/binom/Batfai-Barki/frak/">https://sourceforge.net/p/udprog/code/ci/master/tree/source/binom/Batfai-Barki/frak/</link>.

        </para>
      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Mandelbrot/mandelbrotnagyito.cpp">../Mandelbrot/mandelbrotnagyito.cpp</link>
      </para>

      <para>
        A Mandelbrot halmaz kiszámítása mellett ezzel a programmal a kiadott képen nagyítást is tudunk
        végrehaktani. A kép megnyitása után az egerünk görgőjének segítségével tudunk benne nagyítani, illetve
        touchpad-en a kétújjas mozdulattal.
      </para>

      <programlisting language="c++">
        <![CDATA[#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{
	int szelesseg = 1920;
	int magassag = 1080;
	int iteraciosHatar = 255;
	double a = −1.9;
	double b = 0.7;
	double c = −1.3;
	double d = 1.3;

	if ( argc == 9 )
	{
		szelesseg = atoi ( argv[2] );
		magassag = atoi ( argv[3] );
		iteraciosHatar = atoi ( argv[4] );
		a = atof ( argv[5] );
		b = atof ( argv[6] );
		c = atof ( argv[7] );
		d = atof ( argv[8] );
	}
	else
	{
		std::cout << "Hasznalat: ./3.1.1 fajlnev szelesseg magassag n a b c d" << std::endl;
		std::cout << "Most az alapbeallitasokkal futtatjuk " << szelesseg << " "
		<< magassag << " "
		<< iteraciosHatar << " "
		<< a << " "
		<< b << " "
		<< c << " "
		<< d << " " << std::endl;
		//return −1;
	}]]>
      </programlisting>
      <para>
        A program eleje ismerős hiszen úgyanaz mint az előző programok esetében: header fájlok dekalrálása,
        majd a változók beadagolása (<varname>szelesseg</varname>, <varname>magassag</varname>, <varname>iteraciosHatar</varname>, <varname>a</varname>,
        <varname>b</varname>, <varname>c</varname> és <varname>d</varname>). Most is megvizsgáljuk hogy a parancs
        amivel a felhasználó futtatta a programot, az tényleg 9 argumentumból áll-e. Ha igen akkor az az egyes
        argumentumokat, értékeket átadjuk az egyes változóknak, ha viszont az argumentumok száma nem felel meg,
        akkor használati utasítást adunk a programot futtatónak hogy mi lenne a helyes mód, illetve még segítségképp
        megmutatjuk azt is hogy mik voltak az általunk adott alap beállítások.
      </para>
      <programlisting language="c++">
        <![CDATA[	png::image < png::rgb_pixel > kep ( szelesseg, magassag );

	double dx = ( b − a ) / szelesseg;
	double dy = ( d − c ) / magassag;
	double reC, imC, reZ, imZ;
	int iteracio = 0;
	
	std::cout << "Szamitas\n";
	
	for ( int j = 0; j < magassag; ++j )
	{
		for ( int k = 0; k < szelesseg; ++k )
		{
			reC = a + k * dx;
			imC = d − j * dy;
			std::complex<double> c ( reC, imC );
			
			std::complex<double> z_n ( 0, 0 );
			iteracio = 0;
			
			while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
			{
				z_n = z_n * z_n + c;

				++iteracio;
			}

			iteracio %= 256;

			kep.set_pixel ( k, j,
			png::rgb_pixel ( iteracio%255, 0, 0 ) );
		}

		int szazalek = ( double ) j / ( double ) magassag * 100.0;
		std::cout << "\r" << szazalek << "%" << std::flush;
	}

	kep.write ( argv[1] );
	std::cout << "\r" << argv[1] << " mentve." << std::endl;
	
}]]>
      </programlisting>
      <para>
        A program utolsó része ugynőgy komplexszámos megoldásssal van csinálva. A két for cuklussal végigmegyünk
        a rácson <varname>j</varname>-vel a soron, <varname>k</varname>-val az oszlopon. A a <varname>reC</varname>,
        <varname>imC</varname>, <varname>reZ</varname> és <varname>imZ</varname> (valós és imaginárius részű) változókat
        használva végigmegyünk minden rácsponton úgy, hogy a c=(reC, imC) a haló rácspontjainak megfelelő komplex szám.
        A megadott képletet használva megalkotjuk a várt képet, megkapjuk a "mentve" üzenetet, megnyitjuk a képet
        és tetszésünk szerint nagyítgathatunk a kapott képben aszerint ahogy a feladat legelején bemutattam.
      </para>

      <para>
        Fordítás: <command>g++ mandelbrotnagyito.cpp -lpng16 -O3 -o mandelbrotnagy</command>
      </para>
      <para>
        Futtatás: <command>./mandelbrotnagy mandelnagy.png 1920 1080 1020 0.41276554182095892553405747094075195491310.4127655418245818053080142817634623497725 0.2135387051768746491386963270997512154281 0.2135387051804975289126531379224616102874</command>
      </para>
      <para>
        Kép megnyitása terminálból: <command>eog mandelnagy.png</command>
      </para>
      <figure>
        <title>C++ mandelbrot nagyító és utazó</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Mandelbrot/mandelnagy.png" scale="25"/>
          </imageobject>
          <textobject>
            <phrase>C++ mandelbrot nagyító és utazó</phrase>
          </textobject>
        </mediaobject>
      </figure>


    </section>                     
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
      <para>
        A program célja ugyanaz mint az előző programé: nagyítsunk a kapott képben. A java-s program úgy van megírva,
        hogy itt a bal egérgomb segítségével kell kijelöljük azt a részt amt pontosabban, "közelebbről" megszeretnénk
        tekinteni. Ezt a műveletet nagyon sokszor tudjuk megcsinálni egymás után. A programban commentként rengeteg
        magyarázatot találunk, melyek a különböző sorok, parancsok mülködését írják le.
      </para>
      <para>
        A forráskód megtalálható a következő linken is: <link xlink:href="Mandelbrot/MandelbrotHalmazNagyito.java">../Mandelbrot/MandelbrotHalmazNagyito.java</link>
      </para>
      <programlisting language="java">
        <![CDATA[/*
 * MandelbrotHalmazNagyító.java
 *
 * DIGIT 2005, Javat tanítok
 * Bátfai Norbert, nbatfai@inf.unideb.hu
 *
 */
/**
 * A Mandelbrot halmazt nagyító és kirajzoló osztály.
 *
 * @author Bátfai Norbert, nbatfai@inf.unideb.hu
 * @version 0.0.1
 */
public class MandelbrotHalmazNagyító extends MandelbrotHalmaz {
    /** A nagyítandó kijelölt területet bal felső sarka. */
    private int x, y;
    /** A nagyítandó kijelölt terület szélessége és magassága. */
    private int mx, my;
    /**
     * Létrehoz egy a Mandelbrot halmazt a komplex sík
     * [a,b]x[c,d] tartománya felett kiszámoló és nygítani tudó
     * <code>MandelbrotHalmazNagyító</code> objektumot.
     *
     * @param      a              a [a,b]x[c,d] tartomány a koordinátája.
     * @param      b              a [a,b]x[c,d] tartomány b koordinátája.
     * @param      c              a [a,b]x[c,d] tartomány c koordinátája.
     * @param      d              a [a,b]x[c,d] tartomány d koordinátája.
     * @param      szélesség      a halmazt tartalmazó tömb szélessége.
     * @param      iterációsHatár a számítás pontossága.
     */
    public MandelbrotHalmazNagyító(double a, double b, double c, double d,
            int szélesség, int iterációsHatár) {
        super(a, b, c, d, szélesség, iterációsHatár);
        setTitle("A Mandelbrot halmaz nagyításai");
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent m) {
                x = m.getX();
                y = m.getY();
                mx = 0;
                my = 0;
                repaint();
            }
            public void mouseReleased(java.awt.event.MouseEvent m) {
                double dx = (MandelbrotHalmazNagyító.this.b
                        - MandelbrotHalmazNagyító.this.a)
                        /MandelbrotHalmazNagyító.this.szélesség;
                double dy = (MandelbrotHalmazNagyító.this.d
                        - MandelbrotHalmazNagyító.this.c)
                        /MandelbrotHalmazNagyító.this.magasság;
                new MandelbrotHalmazNagyító(MandelbrotHalmazNagyító.this.a+x*dx,
                        MandelbrotHalmazNagyító.this.a+x*dx+mx*dx,
                        MandelbrotHalmazNagyító.this.d-y*dy-my*dy,
                        MandelbrotHalmazNagyító.this.d-y*dy,
                        600,
                        MandelbrotHalmazNagyító.this.iterációsHatár);
            }
        });]]>
      </programlisting>
      <para>
        A program elején úgyanúgy mint ahogy megszoktuk jönnek a változók deklarálásai, ahol az <varname>x</varname>
        és az <varname>y</varname> változókkal határoljuk be a nagyítandó terület bal felső sarkát, illetve az
        <varname>mx</varname> és <varname>my</varname> pedig a kijelölt nagyítandó terület magassága és szélessége.
        vjuk az ős osztály konstruktorát, beállítjuk az ablak címét (amiben majd nagyítunk) és deklaráljuk az egér
        kattintás müveletét. Az azonnal következő <function>mousePressed</function> függvény segítségével deklaráljuk
        a nagyítandó terület bal felső sarkát, szélességé és magasságát. A következő <function>mouseReleased</function>
        függvénnyel az a művelet aktivizálódik, amikor kattintjuk az egeret, vonszolással kijelöljük a nagyítani kívánt
        területet és amikor elengedjük az egérgombot akkor a kijelölt terület újraszámítása kezdődik el, illetve megalkotódik
        a kinagyított terület, az lesz az aktuális kép amit az ablakban látunk és továbbnagyítunk majd.
      </para>

      <programlisting language="java">
        <![CDATA[        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent m) {
                mx = m.getX() - x;
                my = m.getY() - y;
                repaint();
            }
        });
    }]]>
      </programlisting>
      <para>
        Itt deklaráljuk a fentebb már használt függvényt, ami arra szolgál hogy követni lehessen a
        eglr mozgását, kattintásának feldolgozását, a kijelölés menetét mindazáltal hogy közben
        megadjuk a <function>mouseDragged</function> föggvényt (ami nem más mint a vonszolás, a
        kijelölés menete, az új szélesség és a magasság bellítása és az újraméretezés által).
      </para>

      <programlisting language="java">
        <![CDATA[    public void pillanatfelvétel() {
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
        g.dispose();        
        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotHalmazNagyitas_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");
        // png formátumú képet mentünk
        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }]]>
      </programlisting>
      <para>
        Mint a sima nagyítás nélküli programban, itt is lehetővé tesszük a felhasználó számára
        a pillanatfelvétel készítésének a lehetőségét. Ebben az esetben figyelme vesszük azt is,
        hogy az adott képernyőfotó hányadik volt, mivel hogy könnyebben tudjunk majd eligazodni a
        képek között, a kép nevében szerepelni fog hogy mikor csináltuk azt, hányadikként.
        A fájl nevébe belevesszük, hogy melyik tartományban találtuk a halmazt:
      </para>

      <programlisting language="java">
        <![CDATA[    public void paint(java.awt.Graphics g) {
         g.drawImage(kép, 0, 0, this);         
        if(számításFut) {
            g.setColor(java.awt.Color.RED);
            g.drawLine(0, sor, getWidth(), sor);
        }         
        g.setColor(java.awt.Color.GREEN);
        g.drawRect(x, y, mx, my);
    }

    public static void main(String[] args) {
        new MandelbrotHalmazNagyító(-2.0, .7, -1.35, 1.35, 600, 255);
    }
}]]>
      </programlisting>
      <para>
        A <function>paint</function> segítségével legelőször is kirajzoljuk a Mandelbrot halmazt.
        Ha a számítások éppen futnak, akkor azt hogy melyik sorban tart egy vörös csíkkal jelöljük.
        Végül pedig kirajzoltatjuk a nagyítandó terület körvonalát zöld színnel.
      </para>

      <para>
        Fordítás: <command>javac MandelbrotHalmazNagyító.java</command>
      </para>
      <para>
        Futtatás: <command>java MandelbrotHalmazNagyító</command>
      </para>
      <figure>
        <title>Java mandelbrot nagyító és utazó</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Mandelbrot/mandelnagy.png" scale="45"/>
          </imageobject>
          <textobject>
            <phrase>Java mandelbrot nagyító és utazó</phrase>
          </textobject>
        </mediaobject>
      </figure>
    </section>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        </para>                
    <para>      	
    PolarGen osztály:
    </para>  
    <programlisting language="C++">
<![CDATA[#ifndef POLARGEN_H
#define POLARGEN_H

#include <cstdlib>
#include <cmath>
#include <ctime>

class PolarGen
{
    public:
    PolarGen ()
    {
    nincsTarolt = true;
    std::srand (std::time (NULL));
    }
    ~PolarGen(){
    }
    double kovetkezo();

    private:
    bool nincsTarolt;
    double Tarolt;
};

#endif]]>
    </programlisting> 
      
    <para>  
    A PolarGen osztály definiálása:
    </para>  
      
    <programlisting language="C++">
<![CDATA[#include "polargen.h"

double
PolarGen::kovetkezo ()
{
    if(nincsTarolt){
    double u1, u2, v1, v2, w;
    do{
    u1 = std::rand() / (RAND_MAX + 1.0);
    u2 = std::rand() / (RAND_MAX + 1.0);
    v1 = 2*u1 -1;
    v2 = 2*u2 -1;
    w = v1*v1+v2*v2;
    }
    while( w > 1);
    double r = std::sqrt((-2*std::log(w)) / w);

    Tarolt = r*v2;
    nincsTarolt = !nincsTarolt;
    return r*v1;
    }

    else
    {
    nincsTarolt = !nincsTarolt;
    return Tarolt;
    }
}

]]>
    </programlisting> 

    <para>  
      Majd a mainfüggvényben az osztály példányosítása és használata:
    </para>  
    <programlisting language="C++">
<![CDATA[#include <iostream>
#include "polargen.h"

int main(int argc, char **argv){
    PolarGen pg;

    for (int i = 0; i < 10; ++i)
        std::cout <<pg.kovetkezo() << std::endl;

    return 0;
}
]]>
    </programlisting> 

      <para>
        A forrás megtalálható a Welch/Preorder mappában.
      </para>  

    <para>
        Az osztály az objektum-orientált programozásban használt fogalom. Egy programban különböző feladatokat ellátó részeket osztályokra szeparálhatjuk, melyekkel egy sokkal rendezettebb forráskódot írhatunk, amit így könnyebben is kezelhetünk és olvashatunk.
        Egy osztályban több mező is található, melyek metódusokat, deklarációkat tartalmaznak és így ezek lehetnek publikusak és privátak is, de örököltethetjük is őket. 
        Az osztályokatból objektumokat példányosíthatunk le, melyek az osztály tulajdonságaival fognak rendelkezni. 
    </para>                       

</section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat">https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat</link>.               
        
    </para>
    <para>
      Megoldás a 6.6 feladatban
    </para>
 </section>     
  
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://slideplayer.hu/slide/2200487/">https://slideplayer.hu/slide/2200487/</link>.    
        </para>

    <para>
      Egy bináris fát több féleképpen is bejárhatunk. Három féle bejárási módot ismerünk: Inorder,preorder, posztorder.
    </para>

    <figure>
        <title>Inorder bejárás</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Welch/inorder.jpg" scale="50"/>
            </imageobject>
            <textobject>
                <phrase>Inorder bejárás</phrase>
            </textobject>
        </mediaobject>
    </figure>


    <figure>
        <title>Preorder bejárás</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Welch/preorder.jpg" scale="50"/>
            </imageobject>
            <textobject>
                <phrase>Preorder bejárás</phrase>
            </textobject>
        </mediaobject>
    </figure>


    <figure>
        <title>Postorder bejárás</title>
        <mediaobject>
            <imageobject>
                <imagedata fileref="Welch/postorder.jpg" scale="50"/>
            </imageobject>
            <textobject>
                <phrase>Postorder bejárás</phrase>
            </textobject>
        </mediaobject>
    </figure>

</section>        
                        
<section>
      <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
        
    <para>
      Megoldás a 6.6 feladatban
    </para>
    
</section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
       <para>
            Megoldás videó: <link xlink:href="https://youtu.be/_mu54BDkqiQ">https://youtu.be/_mu54BDkqiQ</link>
        </para>
   
<para>Megoldás a 6.6 feladatban</para>

     </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz másoló/mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva, a másoló értékadás pedig a másoló konstruktorra!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/QBD3zh5OJ0Y">https://youtu.be/QBD3zh5OJ0Y</link>
        </para>
        <para>
            Megoldás forrása:
        </para>

    <para>
        A forráskód a Welch mappában található LZWBinFa.cpp néven
    </para>
    <para>
      A bináris fánk felépítését a BinRandTree osztály létrehozásával kezdjük, ez, mint minden osztály a programunkban template osztály lesz, hogy minél szélesebb körben tudjuk használni a fánkat, azaz több típusra is használhatjuk majd. 
    </para>  
    <para>
      A BinRandTree osztályunk protected részébe beágyazva található a Node osztály, ami a csomópontokat jelenteni. Egy csomópont egy elemet jelent, egy elemnek maximum két gyermeke lehet, egy baloldali és egy jobboldali, ezek új csomópontok lesznek. 
    </para>

        <programlisting language="C++">
<![CDATA[template <typename ValueType>
class BinRandTree {

protected:
    class Node {
        
    private:
        ValueType value;
        Node *left;
        Node *right;
        int count{0};
        
        Node(const Node &);
        Node & operator=(const Node &);
        Node(Node &&);
        Node & operator=(Node &&);

        
    public:
        Node(ValueType value, int count=0): value(value), count(count), left(nullptr), right(nullptr) {}
        ValueType getValue() const { return value; }
        Node * leftChild() const { return left; }
        Node * rightChild() const { return right; }
        void leftChild(Node * node){ left = node; }
        void rightChild(Node * node){ right = node; }
        int getCount() const { return count; }
        void incCount() { ++count; }        
    };
]]>
        </programlisting> 


    <para>
      Szükségünk lesz még mutatókra is, ez lesz a *root (gyökérmutató, ami a fa kezdetét jelenti) és *treep (mutató mellyel bejárhatjuk a fát, ez jelzi hol is járunk éppen). 
    </para>

    <programlisting language="C++">
<![CDATA[

    Node *root;
    Node *treep;    
    int depth{0};

]]>
    </programlisting> 

    <para>
        Ugyanakkor még szükségünk van mozgató és másoló konstruktorra és értékátadásra:
    </para>


        <programlisting language="C++">
<![CDATA[

public:
    BinRandTree(Node *root = nullptr, Node *treep = nullptr): root(root), treep(treep) {
        std::cout << "BT ctor" << std::endl;        
    }
    
    BinRandTree(const BinRandTree & old) {		//Másoló konstruktor
        std::cout << "BT copy ctor" << std::endl;
        
        root = cp(old.root, old.treep); 		//A létrehozott fa *rootjának értékül adjuk a paraméterként kapott fáét
        
    }
    
    Node * cp(Node *node, Node *treep) 			//A másoláshoz szükséges függvény, mely egy Node mutatóval tér vissza
    {
        Node * newNode = nullptr;			// Először létrehozunk egy Node mutatót ami egy nullptr még
        

//A létrehozott mutatónak allokálunk memóriát a paraméterként kapott node adataival


        if(node)
        {
            newNode = new Node(node->getValue(), 42 /*node->getCount()*/);	            
            newNode->leftChild(cp(node->leftChild(), treep));            
            newNode->rightChild(cp(node->rightChild(), treep));
            
            if(node == treep)
                this->treep = newNode;
        }
        
        return newNode;
    }
    
    
    BinRandTree & operator=(const BinRandTree & old) {		//Másoló értékadás		
        std::cout << "BT copy assign" << std::endl;
        
        BinRandTree tmp{old};				//Létrehozunk egy ideiglenes fát ami a paraméterként kapott fa másolata 
        std::swap(*this, tmp);				//majd az egyenlőség bal oldalán lévő fával megcseréljük.
        return *this;
    }
    
    BinRandTree(BinRandTree && old) {			//Mozgató konstruktor
        std::cout << "BT move ctor" << std::endl;
        
        root = nullptr;
        *this = std::move(old);
    }
       
    BinRandTree & operator=(BinRandTree && old) {	//Mozgató értékadás
        std::cout << "BT move assign" << std::endl;
        
        std::swap(old.root, root);
        std::swap(old.treep, treep);
        
        return *this;
    }
    
    ~BinRandTree(){					
        std::cout << "BT dtor" << std::endl;
        deltree(root);


]]>
        </programlisting> 



    </section>
                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
  <section>
    <title>Hangyaszimulációk</title>
    <para>
      Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
      készíts UML osztálydiagramot is!
    </para>
    <para>
      Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
    </para>
    <para>
      Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/-/tree/master/attention_raising%2FMyrmecologist">https://gitlab.com/nbatfai/bhax/-/tree/master/attention_raising%2FMyrmecologist</link>
    </para>

    <figure>
      <title>A hangyaszimulációs program UML diagramja</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="img/uml.png" scale="50"/>
        </imageobject>
        <textobject>
          <phrase>A hangyaszimulációs program UML diagramja</phrase>
        </textobject>
      </mediaobject>
    </figure>

    <para>
      A programunk egy hangyaszimulációs program lesz, mely a hangyáknak egy véletlenszerű mozgását fogja szimulálni.
      A mozgások egy 2 dimenziós területen fognak történni
      A program 3 osztályból épül fel, az
      <link xlink:href="Conway/Myrmecologist/ant.h">
        <filename>Ant</filename>
      </link>

      ,

      <link xlink:href="Conway/Myrmecologist/antthread.h">
        <filename>AntThread</filename>
      </link>

      és

      <link xlink:href="Conway/Myrmecologist/antwin.h">
        <filename>AntWin</filename>
      </link>

      osztályokból, mint azt láthatjuk a fentebbb lévő UML diagrammon is.

    </para>

    <figure>
      <title>Hangyaszimuláció</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="Conway/hangya.png" scale="30"/>
        </imageobject>
        <textobject>
          <phrase>Hangyaszimuláció</phrase>
        </textobject>
      </mediaobject>
    </figure>




  </section>
  <section>
    <title>Java életjáték</title>
    <para>
      Írd meg Java-ban a John Horton Conway-féle életjátékot,
      valósítsa meg a sikló-kilövőt!
    </para>
    <para>
      Megoldás forrása: <link xlink:href="https://regi.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apb.html#conway">https://regi.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apb.html#conway</link>
    </para>

    <para>
      Megtalálható a forráskód:   <link xlink:href="Conway/Sejtautomata.java">
        <filename>Conway/Sejtautomata.java</filename>
      </link>


    </para>


    <para>

      A játékunkban egy sejt egy sejttér eleme, a sejt állapota lehet élő vagy halott. A adott időben működő sejttér adott sejtjének állapotát a következő időpillanatban a következő szabályok alapján számolhatjuk ki:
      -Élő sejt élő marad, ha kettő vagy három élő szomszédja van, különben halott lesz.

      -Halott sejt halott marad, ha három élő szomszédja van, különben élő lesz.

    </para>

    <figure>
      <title>Életjáték</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="Conway/sejtautomata.png" scale="30"/>
        </imageobject>
        <textobject>
          <phrase>Életjáték</phrase>
        </textobject>
      </mediaobject>
    </figure>




  </section>
  <section>
    <title>Qt C++ életjáték</title>
    <para>
      Most Qt C++-ban!
    </para>
    <para>
      Megoldás forrása: <link xlink:href="https://bhaxor.blog.hu/2018/09/09/ismerkedes_az_eletjatekkal">https://bhaxor.blog.hu/2018/09/09/ismerkedes_az_eletjatekkal</link>
    </para>
    <para>
      Megoldás videó: a hivatkozott blogba ágyazva.
    </para>
    <para>
      Ez a programunk két osztályból fog állni. A SejtAblak osztályunkban állítjuk be az ablakunk méretét szélesség és magasság szerint, és ugyanígy állítjuk be a cellák méretét is.
      Ezek a SejtAblak konstruktorában fognak megtörténni
    </para>
    <para>

      Az ablak magasságát és szélességét inicializáljuk a paraméterként kapott számokkal


      <programlisting language="C++">
        <![CDATA[

SejtAblak::SejtAblak(int szelesseg, int magassag, QWidget *parent)
    : QMainWindow(parent)
{
    setWindowTitle("A John Horton Conway-féle életjáték");

    this->magassag = magassag;			
    this->szelesseg = szelesseg;

    cellaSzelesseg = 6;				
    cellaMagassag = 6;



]]>
      </programlisting>


      Láthatjuk, hogy a cellák méretétől függően az ablak mérete is változik.
      A for ciklusokkal a rácson végigmenve a cellákra beállítunk egy-egy boolt,
      amiből majd látjuk, hogy melyik cella lesz halott és melyik élő sejt.


      <programlisting language="C++">
        <![CDATA[setFixedSize(QSize(szelesseg*cellaSzelesseg, magassag*cellaMagassag)); 
    racsok = new bool**[2];
    racsok[0] = new bool*[magassag];
    for(int i=0; i<magassag; ++i)
        racsok[0][i] = new bool [szelesseg];
    racsok[1] = new bool*[magassag];
    for(int i=0; i<magassag; ++i)
        racsok[1][i] = new bool [szelesseg];

    racsIndex = 0;
    racs = racsok[racsIndex];
    // A kiinduló racs minden cellája HALOTT
    for(int i=0; i<magassag; ++i)
        for(int j=0; j<szelesseg; ++j)
            racs[i][j] = HALOTT;
    // A kiinduló racsra "ELOlényeket" helyezünk
    //siklo(racs, 2, 2);
    sikloKilovo(racs, 5, 60);


    eletjatek = new SejtSzal(racsok, szelesseg, magassag, 120, this);
    eletjatek->start();

}
]]>
      </programlisting>

      Miután a SejtSzal konstruktorát meghívjuk, végigvizsgáljuk a sejtek szomszédjait a SejtSzal osztályban lévő szomszedokSzama függvénnyel.




      <programlisting language="C++">
        <![CDATA[
int SejtSzal::szomszedokSzama(bool **racs,
                              int sor, int oszlop, bool allapot) {
    int allapotuSzomszed = 0;
    // A nyolcszomszédok végigzongorázása:
    for(int i=-1; i<2; ++i)
        for(int j=-1; j<2; ++j)
            // A vizsgált sejtet magát kihagyva:
            if(!((i==0) && (j==0))) {
        // A sejttérbõl szélének szomszédai
        // a szembe oldalakon ("periódikus határfeltétel")
        int o = oszlop + j;
        if(o < 0)
            o = szelesseg-1;
        else if(o >= szelesseg)
            o = 0;

        int s = sor + i;
        if(s < 0)
            s = magassag-1;
        else if(s >= magassag)
            s = 0;

        if(racs[s][o] == allapot)
            ++allapotuSzomszed;
    }

    return allapotuSzomszed;
}
]]>
      </programlisting>

      Majd ezt a függvényt felhasználjuk a következő metódusunkban, amiben az élő szomszédok számát ellenőrízzük és eszerint adunk új értéket a vizsgált cellának.



      <programlisting language="C++">
        <![CDATA[
void SejtSzal::idoFejlodes() {

    bool **racsElotte = racsok[racsIndex];
    bool **racsUtana = racsok[(racsIndex+1)%2];

    for(int i=0; i<magassag; ++i) { // sorok
        for(int j=0; j<szelesseg; ++j) { // oszlopok

            int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);

            if(racsElotte[i][j] == SejtAblak::ELO) {
                /* Élõ élõ marad, ha kettõ vagy három élõ
             szomszedja van, különben halott lesz. */
                if(elok==2 || elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }  else {
                /* Halott halott marad, ha három élõ
             szomszedja van, különben élõ lesz. */
                if(elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
        }
    }
    racsIndex = (racsIndex+1)%2;
}
]]>
      </programlisting>

      Fentebb a lényegesebb részeket emeltem ki, a kód többi része megtalálható a Conway/cppeletjatek mappában:

      <link xlink:href="Conway/cppeletjatek/sejtablak.h">
        <filename>SejtAblak</filename>
      </link>

      <link xlink:href="Conway/cppeletjatek/sejtszal.h">
        <filename>SejtSzal</filename>
      </link>
    </para>

    <figure>
      <title>Életjáték</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="Conway/cppelet.png" scale="40"/>
        </imageobject>
        <textobject>
          <phrase>Életjáték</phrase>
        </textobject>
      </mediaobject>
    </figure>



  </section>
  <section>
    <title>BrainB Benchmark</title>
    <para>
    </para>
    <para>
      Megoldás videó: initial hack: <link xlink:href="https://www.twitch.tv/videos/139186614">https://www.twitch.tv/videos/139186614</link>
    </para>
    <para>
      Megoldás forrása: <link xlink:href="https://github.com/nbatfai/esport-talent-search">https://github.com/nbatfai/esport-talent-search</link>
    </para>

    <para>

      A BrainB program tulajdonképpen az embert vizsgálja. Tapasztalhattuk már, hogy különböző játékokban, az irányított karakterünket szem elől veszítjük különböző tényezők hatására.
      Mint például ha még több karakter gyűlik a miénk köré, esetleg különböző effektek is takarják a láthatóságát közben. Ilyenkor nehéz követni, hogy mi hol is vagyunk, mit csinálunk éppen. A BrainB program pont ezt a képességünket méri. A programban, mint láthatjuk a lentebb lévő képünkön, sok kis négyzet között, melyeknek a közepén egy pont van, egyik a saját négyzetünk.

    </para>
    <para>
      A mi feladatunk, hogy azt a négyzetet kövessük az egérmutatónkkal. Erre időlimit van, maximum 10 percig követhetjük a négyzetünket és közben lenyomva kell tartanunk a balegérgombunkat.
      Végül kapunk egy eredményt abból számítva, hogy hányszor vesztettük el a négyzetünket, mennyire tudtuk követni.
    </para>





    <para>

      <figure>
        <title>BrainB program és kimenete</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="img/brainb.jpg" scale="50"/>
          </imageobject>
          <textobject>
            <phrase>BrainB program és kimenete</phrase>
          </textobject>
        </mediaobject>
      </figure>

    </para>
  </section>

</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
  <info>
    <title>Helló, Schwarzenegger!</title>
    <keywordset>
      <keyword/>
    </keywordset>
  </info>
  <section xml:id="hax-textbook-feladatok-schwarzenegger">
    <title>Szoftmax Py MNIST</title>
    <para>
      Python (lehet az SMNIST <citation>SMNIST</citation> is a példa).
    </para>
    <para>
      Megoldás videó: <link xlink:href="https://youtu.be/j7f9SkJR3oc">https://youtu.be/j7f9SkJR3oc</link>
    </para>
    <para>
      Megoldás forrása: <link xlink:href="https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0">https://github.com/tensorflow/tensorflow/releases/tag/v0.9.0</link> (/tensorflow-0.9.0/tensorflow/examples/tutorials/mnist/), <link xlink:href="https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol">https://progpater.blog.hu/2016/11/13/hello_samu_a_tensorflow-bol</link>
    </para>
    <para>
      A programunk célja, hogy a neurális hálónkat betanítsa és hogy az MNIST-ben lévő számokat fel tudja ismerni, majd ennek a hatékonyságát közli velünk.
      Az MNIST adatbázis egy kézzel írott számok képeiből álló adatbázis, amelyet gyakran használnak a gépi tanulás köreiben és képfeldolgozó rendszerek tanítására.
      A tensorflow egy gépi tanulásra készített library amelyet a google fejlesztett ki, a programunkban ezt is használni fogjuk.



    </para>

    <programlisting language="Python">
      <![CDATA[

#először is importáljuk a tensorflow könyvtárat és az mnist datesetjét betöltjük.

import tensorflow as tf

mnist = tf.keras.datasets.mnist

(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0

#Felépítjük a modellünket, ez egy 28x28-as kép lesz

model = tf.keras.models.Sequential([
  tf.keras.layers.Flatten(input_shape=(28, 28)),
  tf.keras.layers.Dense(128, activation='relu'),
  tf.keras.layers.Dropout(0.2),
  tf.keras.layers.Dense(10)
])

predictions = model(x_train[:1]).numpy()
predictions

tf.nn.softmax(predictions).numpy()

loss_fn = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True)

loss_fn(y_train[:1], predictions).numpy()

#Itt a program hatékonyságát számoljuk ki

model.compile(optimizer='adam',
              loss=loss_fn,
              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=5)

model.evaluate(x_test,  y_test, verbose=2)

probability_model = tf.keras.Sequential([
  model,
  tf.keras.layers.Softmax()
])

probability_model(x_test[:5])




]]>

</programlisting>


  </section>

  <!--
    <section>
        <title>Szoftmax R MNIST</title>
        <para>
            R            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->

  <section>
    <title>Mély MNIST</title>
    <para>
      Python (MNIST vagy SMNIST, bármelyik, amely nem a softmaxos, például lehet egy CNN-es).
    </para>
    <para>
      Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/03/10/the_semantic_mnist">https://bhaxor.blog.hu/2019/03/10/the_semantic_mnist</link>
    </para>
    <para>
      Megoldás forrása: SMNIST, <link xlink:href="https://gitlab.com/nbatfai/smnist">https://gitlab.com/nbatfai/smnist</link>
    </para>
    <para>
      A programunk hasonló az előző feladatban lévőhöz, itt viszont egy képet átadva a programnak, megpróbálja felismerni, hogy a képen milyen szám van.
    </para>


    <programlisting language="Python">
      <![CDATA[
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Conv2D, Dropout, Flatten, MaxPooling2D

from PIL import Image
import numpy as np
import sys

#A következő három sort kommentbe raktam, így tudott csak lefutni a gépemen a program

#physical_devices = tf.config.experimental.list_physical_devices('GPU')
#assert len(physical_devices) > 0, "Not enough GPU hardware devices available"
#tf.config.experimental.set_memory_growth(physical_devices[0], True)

(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()

#A kapott képet itt újraméretezzük

x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train /= 255
x_test /= 255


model = Sequential()
model.add(Conv2D(28, kernel_size=(3,3), input_shape=(28, 28, 1)))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Flatten())
model.add(Dense(128, activation=tf.nn.relu))
model.add(Dropout(0.2))
model.add(Dense(10,activation=tf.nn.softmax))

tb_log_dir = "./cnn_tb"
file_writer = tf.summary.create_file_writer(tb_log_dir)
file_writer.set_as_default()
tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=tb_log_dir, profile_batch=0)

model.compile(optimizer='adam', 
              loss='sparse_categorical_crossentropy', 
              metrics=['accuracy'])

model.fit(x=x_train,y=y_train, epochs=10, callbacks=[tensorboard_callback])

model.evaluate(x_test, y_test)

input_image = np.array(Image.open(sys.argv[1]).getdata(0).resize((28, 28), 0))

pred = model.predict(input_image.reshape(1, 28, 28, 1))

print (pred)

print("The number is = ", pred.argmax())



]]>
    </programlisting>


  </section>
  <!--
    <section>
        <title>Deep dream</title>
        <para>
            Keras            
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
-->
  <section>
    <title>Minecraft-MALMÖ</title>
    <para>
      Most, hogy már van némi ágensprogramozási gyakorlatod, adj egy rövid általános áttekintést a MALMÖ projektről!
    </para>
    <para>
      Megoldás videó: initial hack: <link xlink:href="https://youtu.be/bAPSu3Rndi8">https://youtu.be/bAPSu3Rndi8</link>.
      Red Flower Hell: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>.
    </para>
    <para>
      Megoldás forrása:
    </para>
    <para>
      A Malmö Projekt egy minecraft mod, amit a Microsoft készített. Itt célunk kódokkal irányítani a karakterünket, ezzel a mesterséges intelligencia
      felé próbálunk közelíteni. A kódjainkban igyekszünk úgy irányítani a karakterünket, hogy különböző szituációkkor különféleképpen cselekedjen.
      Az egyetemen a mi feladatunk az volt, hogy egy legenerált pályán Steve (a minecraft karakterünk) járja körbe az arénát, érzékelje a környezetét
      és keressen, majd szedjen fel minél több virágot akadálymentesen mielőtt az arénánk oldalain lefolyó lávával találkozik,
      tehát ha például csapdába esik, akkor abból szabaduljon ki, ha virág van a közelében, akkor úgy lépjen, hogy azt fel tudja venni, stb.


    </para>
 <!-- </section>
  <section>
    <title>Vörös Pipacs Pokol/javíts a 19 RF-en</title>
    <para>
      Megoldás forrása: <link xlink:href="https://github.com/nbatfai/RedFlowerHell">https://github.com/nbatfai/RedFlowerHell</link>
    </para>
    <para>
      Schwarzenegger mappában található 30RF.py néven
    </para>
  </section>
  -->
    </section>
</chapter>     

    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chaitin!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Iteratív és rekurzív faktoriális Lisp-ben</title>
        <para>
                
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/z6NJE2a1zIA">https://youtu.be/z6NJE2a1zIA</link>      
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
<!--        
    <section>
        <title>Weizenbaum Eliza programja</title>
        <para>
            Éleszd fel Weizenbaum Eliza programját!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->
    <section>
        <title>Gimp Scheme Script-fu: króm effekt</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely megvalósítja a króm effektet egy 
            bemenő szövegre!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/OKdAkI_c7Sc">https://youtu.be/OKdAkI_c7Sc</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Chrome</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>    
    </section>        

    <section>
        <title>Gimp Scheme Script-fu: név mandala</title>
        <para>
            Írj olyan script-fu kiterjesztést a GIMP programhoz, amely név-mandalát készít a
            bemenő szövegből!               
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv">https://bhaxor.blog.hu/2019/01/10/a_gimp_lisp_hackelese_a_scheme_programozasi_nyelv</link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/GIMP_Lisp/Mandala</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        

<!--    
    <section>
        <title>Lambda</title>
        <para>
            Hasonlítsd össze a következő programokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>      
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
-->    

<!--
    <section>
        <title>Omega</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
-->                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
</chapter>     
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
  <info>
    <title>Helló, Gutenberg!</title>
    <keywordset>
      <keyword/>
    </keywordset>
    <cover>
      <para>
        Programozás tankönyvek rövid olvasónaplói.
      </para>
    </cover>
  </info>


  <section>
    <title>Programozási alapfogalmak</title>
    <para>
      <citation>PICI</citation>
    </para>
    <para>
      1.2 Alapfogalmak
    </para>
    <para>
      A számítógépes programozás három nyelvét különböztethetjük meg: gépi nyelv, assembly szintű nyelv,
      vagy magas szintű nyelv. Egy magas szintű programnyelvet a szintaktikai és szemantikai szabályai
      határoznak meg, és jelen kell lennie mindkettőnek. A szintaktika a formai szabályok, míg a szemtanika
      a tartalmi, jelentésbeli szabályok együttese. Ahhoz, hogy egy magas szintű programozási nyelven megírt
      programot le tudjunk futtatni, azt előbb le kell fordítani a processzor saját gépi nyelvére. Erre
      kétféle lehetőségünk van, a fordítóprogramos és az interpreteres.
    </para>
    <para>
      A fordítóprogram a magas szintű nyelvű forrásból egy gépi kódú tárgyprogramot kreál négy lépésben.
      Lexikális elemzés, szintaktikai elemzés, szemantikai elemzés, majd kódgenerálás. Amennyiben az adott nyelv 
      szabályai szerint szintaktikailag helyes, az elkészült tárgyprogramból a kapcsolatszerkesztő állít elő
      egy már ténylegesen futtatható programot.
    </para>
    <para>
      Az interpreteres megoldás esetén is megvan az első három lépés, de itt nem készül tárgyprogram. Helyette
      utasításonként sorra veszi a forrásprogramot, értelmezi, majd végre is hajtja azt.
    </para>
    <para>
      A programnyelvek lehetnek vagy fordítóprogramosak, vagy interpreteresek is, de lehetnek egyszerre mindkettő is.
    </para>
  </section>


  <section>
    <title>Programozás bevezetés</title>
    <para>
      <citation>KERNIGHANRITCHIE</citation>
    </para>
    <para>
      Megoldás videó: <link xlink:href="https://youtu.be/zmfT9miB-jY">https://youtu.be/zmfT9miB-jY</link>
    </para>
    <para>
      Alapismeretek
    </para>
    <para>
      Az első fejezet, mint bevezetés, írat velünk egy egyszerű helloworld programot, ezzel megtanítva,
      egyszersmint begyakoroltatva velünk az alapvető szintaktikát, valamint a fordítás és futtatás
      mikéntjét. A továbbiakban új alapfogalmakat tanít, mint hogy a C-beli programok .c-re végződnek,
      vagy épp hogy mi az a változó és milyen típusai vannak. Ezután találkozhatunk még olyan fontos
      elemekkel, mint a ciklusok, feltételes elágazások, tömbök és függvények. Az olvasót végig arra
      próbálják sarkallni, hogy minél többet gyakoroljon.
    </para>
    <para>
      Típusok, operátorok és kifejezések
    </para>
    <para>
      A második fejezetben olvashatunk bővebben a változókról, például a nevükhöz tartozó konvenciókról,
      a típusokról és azok méreteiről. Bővebb szó esik az értékadásról, megjelennek a konstansok. Érdemben
      tárgyal az aritmetikai, relációs és logikai operátorokról. Típuskonverziók.
    </para>
  </section>


  <section>
    <title>Programozás</title>
    <para>
      <citation>BMECPP</citation>
    </para>
    <para>
      Ebben a kis olvasmányban megismerhettük a C++ és elődje, a C közötti néhány különbséget.
      C-vel ellentétben C++-ban az üres paraméterlista <type>void</type> visszatérési értéket jelent.
      Szintén lényeges különbséget jelent, hogy már nem kötelező a return használata, azt a fordítóprogram
      automatikusan a végére teszi. C++-ban megjelent a <type>bool</type> típusú változó, ami logikai
      igaz/hamis értékekkel dolgozik. Ebből kifolyólag a nyelv kulcsszavai részévé váltak a bool, true és
      false kifejezések.
    </para>
  </section>


  <section>
    <title>Mobilprogramozás</title>
    <para>
      <citation>MOBIL</citation>
    </para>
    <para>
      2.3. Python
    </para>
    <para>
      A Python egy magas szintű, általános célú programozási nyelv melyet a szkriptnyelvek családjába szoktak sorolni.
      A Pythonban megírt programokat általában valamilyen fejlesztői környezetben tudjuk futtatni. Egyik nagy előnye, hogy
      rendelkezik egy rendkívül hasznos alapkönyvtárral, mely számos praktikus segítséget tartalmaz, ilyenek például
      a szabványos kifejezések. Másik nagy előnye a bővíthetőség, C-ben vagy C++-ban írt programrészekkel is kompatibilis
      tud lenni, így azokkal könnyen bővíteni lehet a kódot. Népszerűsége egyszerűségéből fakad. Fontos hátulütője viszont,
      hogy a legtöbb mobil alapvetően nem rendelkezik Python-futtató-környezettel, így hiába egyszerűbb megírni egy
      programot, nehezebb terjeszteni azt. Ha viszont egy mobil rendelkezik Python-futtató-környezettel, akkor lehetővé
      teszi azt is, hogy mobilon programozzunk és teszteljünk is, bár előbbi nem ajánlott hosszabb programkódok esetén.
    </para>
  </section>
</chapter>     
            
</part>                                                              

    <part xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Második felvonás</title>
    <partintro>
        <para> 
        </para>
<tip>
              <title>Bátf41 Haxor Stream</title>
              <para>
                  A feladatokkal kapcsolatos élő adásokat sugároz
                  a <link xlink:href="https://www.twitch.tv/nbatfai">https://www.twitch.tv/nbatfai</link> csatorna,
                  melynek permanens archívuma a <link xlink:href="https://www.youtube.com/c/nbatfai">https://www.youtube.com/c/nbatfai</link> 
                  csatornán található.
              </para>            
            </tip>    
        
    </partintro>
    
    <chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>A BPP algoritmus Java megvalósítása</title>
        <para>
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        

    <section>
        <title>Java osztályok a Pi-ben</title>
        <para>
            Az előző feladat kódját fejleszd tovább: vizsgáld, hogy Vannak-e Java osztályok a Pi hexadecimális kifejtésében!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>        
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>     
    
    
            
</part>                                                              


    <bibliography xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <title>Irodalomjegyzék</title>
    <bibliodiv>
        <title>Általános</title>
        <biblioentry xml:lang="hu">
            <abbrev>MARX</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>György</firstname>
                        <surname>Marx</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Gyorsuló idő</title>
            <publisher>
                <publishername>
                    Typotex
                </publishername>
            </publisher>
            <pubdate>2005</pubdate>
        </biblioentry>  
    </bibliodiv> 
    <bibliodiv>
        <title>C</title>
        <biblioentry>
            <abbrev>KERNIGHANRITCHIE</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Brian W.</firstname>
                        <surname>Kernighan</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Dennis M.</firstname>
                        <surname>Ritchie</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>A C programozási nyelv</title>
            <publisher>
                <publishername>Bp., Műszaki</publishername>
            </publisher>
            <pubdate>1993</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>C++</title>
        <biblioentry>
            <abbrev>BMECPP</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Zoltán</firstname>
                        <surname>Benedek</surname>
                    </personname>
                </author>
                <author>
                    <personname>
                        <firstname>Tihamér</firstname>
                        <surname>Levendovszky</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>Szoftverfejlesztés C++ nyelven</title>
            <publisher>
                <publishername>Bp., Szak Kiadó</publishername>
            </publisher>
            <pubdate>2013</pubdate>
        </biblioentry>            
    </bibliodiv>
    <bibliodiv>
        <title>Lisp</title>
        <biblioentry>
            <abbrev>METAMATH</abbrev>
            <authorgroup>
                <author>
                    <personname>
                        <firstname>Gregory</firstname>
                        <surname>Chaitin</surname>
                    </personname>
                </author>
            </authorgroup>
            <title>META MATH! The Quest for Omega</title>
            <publisher>
                <publishername>
                    <link xlink:href="http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf">http://arxiv.org/PS_cache/math/pdf/0404/0404335v7.pdf</link>
                </publishername>
            </publisher>
            <pubdate>2004</pubdate>
        </biblioentry> 
    </bibliodiv>    
</bibliography>     
          
            <acknowledgements xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <para>
        Köszönet illeti a
        NEMESPOR, <link xlink:href="https://groups.google.com/forum/#!forum/nemespor">https://groups.google.com/forum/#!forum/nemespor</link>, 
        az UDPROG tanulószoba, <link xlink:href="https://www.facebook.com/groups/udprog">https://www.facebook.com/groups/udprog</link>, 
        a DEAC-Hackers előszoba, <link xlink:href="https://www.facebook.com/groups/DEACHackers">https://www.facebook.com/groups/DEACHackers</link> 
        (illetve egyéb alkalmi szerveződésű szakmai csoportok) 
        tagjait inspiráló érdeklődésükért és hasznos észrevételeikért.         
    </para>                 
    <para>
        Ezen túl kiemelt köszönet illeti az említett UDPROG közösséget, mely a Debreceni Egyetem reguláris 
        programozás oktatása tartalmi szervezését támogatja. Sok példa eleve ebben a közösségben született, vagy itt került
        említésre és adott esetekben szerepet kapott, mint oktatási példa.         
    </para>                 
</acknowledgements>     

</book>
